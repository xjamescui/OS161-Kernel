diff --git a/.gitignore b/.gitignore
index ccea0c4..faad5c3 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,3 +7,8 @@ defs.mk
 build
 /user/testbin/randcall/calls.c
 *.swp
+*.out
+*.swo
+.vimrc
+kern/thread/or
+
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..64ebeb9 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -72,10 +72,16 @@ void V(struct semaphore *);
  * The name field is for easier debugging. A copy of the name is
  * (should be) made internally.
  */
+
+ // Stuff was added here for ASST1.
 struct lock {
-        char *lk_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+
+  // (don't forget to mark things volatile as needed)
+  char *lk_name;
+  struct wchan *lk_wchan;
+  struct spinlock lk_spinlock;
+  volatile struct thread *lk_curthread;
+  volatile int lk_hold;
 };
 
 struct lock *lock_create(const char *name);
@@ -111,10 +117,14 @@ void lock_destroy(struct lock *);
  * (should be) made internally.
  */
 
+// Stuff was added here for ASST1
 struct cv {
-        char *cv_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+
+  // add what you need here
+
+  char              *cv_name;
+  struct wchan      *cv_wchan;
+  struct spinlock    cv_spinlock;
 };
 
 struct cv *cv_create(const char *name);
@@ -142,7 +152,14 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
  */
 
 struct rwlock {
-        char *rwlock_name;
+
+  char              *rwl_name;
+  struct spinlock    rwl_spinlock;
+  struct wchan      *rwl_rwchan;
+  struct wchan      *rwl_wwchan;
+  int                mode;
+  struct semaphore  *rwl_rsem;
+  struct semaphone  *rwl_wsem;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..fa12650 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,5 @@
+// vtangira@buffalo.edu
+
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..410c123 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,7 +47,18 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+// Male start, female start. Male end, Female end.
+// Much better than the quantum hanky-panky I had to present with the 
+// bacteria.
+struct semaphore *ms, *fs, *me, *fe;
+
 void whalemating_init() {
+
+  ms = sem_create("Male Start", 0);
+  fs = sem_create("Female Start", 0);
+  me = sem_create("Male End", 0);
+  fe = sem_create("Female End", 0);
+
   return;
 }
 
@@ -55,6 +66,12 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+
+  sem_destroy(ms);
+  sem_destroy(fs);
+  sem_destroy(me);
+  sem_destroy(fe);
+
   return;
 }
 
@@ -65,7 +82,11 @@ male(void *p, unsigned long which)
   (void)which;
   
   male_start();
-	// Implement this function 
+
+	// Implement this function
+  V(ms);
+  P(me);
+
   male_end();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -81,7 +102,11 @@ female(void *p, unsigned long which)
   (void)which;
   
   female_start();
+
 	// Implement this function 
+  V(fs);
+  P(fe);
+
   female_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -97,7 +122,13 @@ matchmaker(void *p, unsigned long which)
   (void)which;
   
   matchmaker_start();
+
 	// Implement this function 
+  P(ms);
+  P(fs);
+  V(me);
+  V(fe);
+
   matchmaker_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -137,6 +168,8 @@ matchmaker(void *p, unsigned long which)
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+// All Car's should drive on the left, unless you're a lefty and the config
+// makes sense.
 void stoplight_init() {
   return;
 }
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..2982e55 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -162,9 +162,22 @@ lock_create(const char *name)
                 kfree(lock);
                 return NULL;
         }
-        
+
         // add stuff here as needed
-        
+
+        lock->lk_wchan = wchan_create("Lock wchan");
+        if (lock->lk_wchan == NULL) {
+          kfree (lock->lk_name);
+          kfree (lock);
+          return NULL;
+        }
+
+        spinlock_init(&lock->lk_spinlock);
+        lock->lk_curthread = NULL;
+        lock->lk_hold = 0;
+
+        //end
+
         return lock;
 }
 
@@ -174,7 +187,14 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+
+        if (lock->lk_hold == 0) {
+          spinlock_cleanup(&lock->lk_spinlock);
+          wchan_destroy(lock->lk_wchan);
+        }
+        else
+          panic("Lock destory called when being held. Bad code, bad");
+        //end
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -184,7 +204,24 @@ lock_acquire(struct lock *lock)
 {
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+        spinlock_acquire(&lock->lk_spinlock);
+
+        while(lock->lk_hold == 1) {
+
+          wchan_lock(lock->lk_wchan);
+          spinlock_release(&lock->lk_spinlock);
+          wchan_sleep(lock->lk_wchan);
+          spinlock_acquire(&lock->lk_spinlock);
+        }
+
+        lock->lk_hold = 1;
+        lock->lk_curthread = curthread;
+
+        spinlock_release(&lock->lk_spinlock);
+
+        //end
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
@@ -192,7 +229,27 @@ lock_release(struct lock *lock)
 {
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+        KASSERT(lock != NULL);
+
+        //spinlock_acquire(&lock->lk_spinlock);
+
+        if (lock_do_i_hold(lock)) {
+
+          spinlock_acquire(&lock->lk_spinlock);
+          lock->lk_curthread = NULL;
+          lock->lk_hold = 0;
+          // Two days of struggle and me not
+          // reading the code right was the
+          // problem!!! wchan will not wake
+          // someone up randomly. This is there
+          // in the wchan include file.
+          wchan_wakeone(lock->lk_wchan);
+          spinlock_release(&lock->lk_spinlock);
+        }
+
+        //end
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
@@ -200,9 +257,18 @@ lock_do_i_hold(struct lock *lock)
 {
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+        KASSERT(curthread->t_in_interrupt == false);
+
+        if (curthread == lock->lk_curthread)
+          return true;
+        else
+          return false;
+
+        //end
+
+        //(void)lock;  // suppress warning until code gets written
 
-        return true; // dummy until code gets written
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -213,55 +279,215 @@ lock_do_i_hold(struct lock *lock)
 struct cv *
 cv_create(const char *name)
 {
-        struct cv *cv;
 
-        cv = kmalloc(sizeof(struct cv));
-        if (cv == NULL) {
-                return NULL;
-        }
+  struct cv *cv;
 
-        cv->cv_name = kstrdup(name);
-        if (cv->cv_name==NULL) {
-                kfree(cv);
-                return NULL;
-        }
-        
-        // add stuff here as needed
-        
-        return cv;
+  cv = kmalloc(sizeof(struct cv));
+  if (cv == NULL) {
+    return NULL;
+  }
+
+  cv->cv_name = kstrdup(name);
+  if (cv->cv_name==NULL) {
+    kfree(cv);
+    return NULL;
+  }
+
+  // add stuff here as needed
+
+  cv->cv_wchan = wchan_create("CV wchan");
+  if (cv->cv_wchan == NULL) {
+
+    kfree(cv->cv_name);
+    kfree(cv);
+    return NULL;
+  }
+
+  spinlock_init(&cv->cv_spinlock);
+
+  // end add stuff
+
+  return cv;
 }
 
 void
 cv_destroy(struct cv *cv)
 {
-        KASSERT(cv != NULL);
 
-        // add stuff here as needed
-        
-        kfree(cv->cv_name);
-        kfree(cv);
+  KASSERT(cv != NULL);
+
+  // add stuff here as needed
+
+  spinlock_cleanup(&cv->cv_spinlock);
+  wchan_destroy(cv->cv_wchan);
+
+  // end add stuff
+
+  kfree(cv->cv_name);
+  kfree(cv);
 }
 
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+
+  // Write this
+
+  int spinlock_flag = 0;
+
+  KASSERT(curthread->t_in_interrupt == false);
+
+  spinlock_acquire(&cv->cv_spinlock);
+
+  if (lock_do_i_hold(lock)) {
+
+    lock_release(lock);
+
+    wchan_lock(cv->cv_wchan);
+    spinlock_flag = 1;
+    spinlock_release(&cv->cv_spinlock);
+
+    wchan_sleep(cv->cv_wchan);
+    lock_acquire(lock);
+
+  }
+
+  // If you don't hold the lock
+  if (!spinlock_flag)
+    spinlock_release(&cv->cv_spinlock);
+
+  // end write this
+
+  // (void)cv;    // suppress warning until code gets written
+  // (void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+
+  // Write this
+
+  int spinlock_flag = 0;
+
+  KASSERT(curthread->t_in_interrupt == false);
+
+  spinlock_acquire(&cv->cv_spinlock);
+
+  if (lock_do_i_hold(lock)) {
+
+    spinlock_acquire(&cv->cv_spinlock);
+    wchan_wakeone(cv->cv_wchan);
+    spinlock_flag = 1;
+    spinlock_release(&cv->cv_spinlock);
+  }
+
+  if (!spinlock_flag)
+    spinlock_release(&cv->cv_spinlock);
+
+  // end write this
+
+  //(void)cv;    // suppress warning until code gets written
+  //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
-	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+
+  // Write this
+
+  int spinlock_flag = 0;
+
+  KASSERT(curthread->t_in_interrupt == false);
+
+  spinlock_acquire(&cv->cv_spinlock);
+
+  if (lock_do_i_hold(lock)) {
+
+    wchan_wakeall(cv->cv_wchan);
+
+    spinlock_flag = 1;
+
+    spinlock_release(&cv->cv_spinlock);
+  }
+
+  if (!spinlock_flag)
+    spinlock_release(&cv->cv_spinlock);
+
+  // end write this
+
+  //(void)cv;    // suppress warning until code gets written
+  //(void)lock;  // suppress warning until code gets written
+}
+
+
+/////////////////////////////////////////////////////
+// RW Locks
+//
+
+/*struct rwlock * rwlock_create(const char *name) {
+
+  struct rwlock *rwlock;
+
+  rwlock = kmalloc(sizeof(struct rwlock));
+  if (rwlock == NULL) return NULL;
+
+  rwlock->rwl_name = kstrdup(name);
+  if (rwlock->rwl_name == NULL) {
+    kfree(lock);
+    return NULL;
+  }
+
+  rwlock->rwl_rwchan = wchan_create("RWLock Reader Wait Channel");
+  rwlock->rwl_wwchan = wchan_create("RWLock Writer Wait Channel");
+  if (rwlock->rwl_rwchan == NULL || rwlock->rwl_rwchan == NULL) {
+    kfree (rwlock->rwl_name);
+    kfree (rwlock);
+    return NULL;
+  }
+
+  spinlock_init(&rwlock->rwl_spinlock);
+
+  mode = -1;
+
+  sem_create(rwlock->rwl_rsem);
+  sem_create(rwlock->rwl_wsem);
+  if (rwlock->rwl_rsem == NULL || rwlock->rwl_wsem == NULL) {
+    kfree (rwlock->rwl_name);
+    kfree (rwlock);
+  }
+  return rwlock;
+}
+
+void rwlock_destory(struct rwlock *rwlock) {
+
+  KASSERT(rwlock != NULL);
+
+  spinlock_cleanup (&rwlock->rwl_spinlock);
+  wchan_destroy (rwlock->rwl_rwchan);
+  wchan_destroy (rwlock->rwl_wwchan);
+  sem_destory (rwlock->rsem);
+  sem_destory (rwlock->wsem);
+  kfree (rwlock->rwl_name);
+  kfree (rwlock);
 }
+
+void rwlock_acquire_read(struct rwlock *rwlock) {
+
+  KASSERT(rwlock != NULL)
+
+}
+
+void rwlock_read_release(struct rwlock * rwlock) {
+
+  KASSERT(rwlock != NULL);
+
+}
+
+void rwlock_acquire_write(struct rwlock *rwlock) {
+
+  (void) rwlock;
+
+  return;
+}*/
