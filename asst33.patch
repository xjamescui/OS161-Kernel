diff --git a/.gitignore b/.gitignore
index ccea0c4..a09039b 100644
--- a/.gitignore
+++ b/.gitignore
@@ -7,3 +7,9 @@ defs.mk
 build
 /user/testbin/randcall/calls.c
 *.swp
+*.out
+*.swo
+.vimrc
+kern/thread/or
+*.swn
+tags
diff --git a/kern/arch/mips/include/types.h b/kern/arch/mips/include/types.h
index 707d61e..7d00651 100644
--- a/kern/arch/mips/include/types.h
+++ b/kern/arch/mips/include/types.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
diff --git a/kern/arch/mips/include/vm.h b/kern/arch/mips/include/vm.h
index af393c7..27405f5 100644
--- a/kern/arch/mips/include/vm.h
+++ b/kern/arch/mips/include/vm.h
@@ -1,35 +1,15 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
 #ifndef _MIPS_VM_H_
 #define _MIPS_VM_H_
 
+// Virtual page struct.
+/*struct Page {
+
+  struct addrspace Page_addr; // The addrspace the page is mapped to.
+  paddr_t Page_ppage; // The physical equivalent.
+  int Page_state; // Fixed - 0, Free - 1, Dirty - 2, Clean - 3
+  time_t Page_timestamp; // For eviction.
+};*/
+
 
 /*
  * Machine-dependent VM system definitions.
@@ -53,7 +33,7 @@
 #define MIPS_KSEG1  0xa0000000
 #define MIPS_KSEG2  0xc0000000
 
-/* 
+/*
  * The first 512 megs of physical space can be addressed in both kseg0 and
  * kseg1. We use kseg0 for the kernel. This macro returns the kernel virtual
  * address of a given physical address within that range. (We assume we're
@@ -61,7 +41,7 @@
  *
  * N.B. If you, say, call a function that returns a paddr or 0 on error,
  * check the paddr for being 0 *before* you use this macro. While paddr 0
- * is not legal for memory allocation or memory management (it holds 
+ * is not legal for memory allocation or memory management (it holds
  * exception handler code) when converted to a vaddr it's *not* NULL, *is*
  * a valid address, and will make a *huge* mess if you scribble on it.
  */
@@ -109,11 +89,11 @@ void ram_getsize(paddr_t *lo, paddr_t *hi);
  */
 
 struct tlbshootdown {
-	/*
-	 * Change this to what you need for your VM design.
-	 */
-	struct addrspace *ts_addrspace;
-	vaddr_t ts_vaddr;
+  /*
+   * Change this to what you need for your VM design.
+   */
+  struct addrspace *ts_addrspace;
+  vaddr_t ts_vaddr;
 };
 
 #define TLBSHOOTDOWN_MAX 16
diff --git a/kern/arch/mips/locore/trap.c b/kern/arch/mips/locore/trap.c
index ff39633..4db7520 100644
--- a/kern/arch/mips/locore/trap.c
+++ b/kern/arch/mips/locore/trap.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -51,19 +51,19 @@ void mips_trap(struct trapframe *tf);
 /* Names for trap codes */
 #define NTRAPCODES 13
 static const char *const trapcodenames[NTRAPCODES] = {
-	"Interrupt",
-	"TLB modify trap",
-	"TLB miss on load",
-	"TLB miss on store",
-	"Address error on load",
-	"Address error on store",
-	"Bus error on code",
-	"Bus error on data",
-	"System call",
-	"Break instruction",
-	"Illegal instruction",
-	"Coprocessor unusable",
-	"Arithmetic overflow",
+  "Interrupt",
+  "TLB modify trap",
+  "TLB miss on load",
+  "TLB miss on store",
+  "Address error on load",
+  "Address error on store",
+  "Bus error on code",
+  "Bus error on data",
+  "System call",
+  "Break instruction",
+  "Illegal instruction",
+  "Coprocessor unusable",
+  "Arithmetic overflow",
 };
 
 /*
@@ -73,48 +73,57 @@ static
 void
 kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 {
-	int sig = 0;
-
-	KASSERT(code < NTRAPCODES);
-	switch (code) {
-	    case EX_IRQ:
-	    case EX_IBE:
-	    case EX_DBE:
-	    case EX_SYS:
-		/* should not be seen */
-		KASSERT(0);
-		sig = SIGABRT;
-		break;
-	    case EX_MOD:
-	    case EX_TLBL:
-	    case EX_TLBS:
-		sig = SIGSEGV;
-		break;
-	    case EX_ADEL:
-	    case EX_ADES:
-		sig = SIGBUS;
-		break;
-	    case EX_BP:
-		sig = SIGTRAP;
-		break;
-	    case EX_RI:
-		sig = SIGILL;
-		break;
-	    case EX_CPU:
-		sig = SIGSEGV;
-		break;
-	    case EX_OVF:
-		sig = SIGFPE;
-		break;
-	}
-
-	/*
-	 * You will probably want to change this.
-	 */
-
-	kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
-		code, sig, trapcodenames[code], epc, vaddr);
-	panic("I don't know how to handle this\n");
+  int sig = 0;
+
+  KASSERT(code < NTRAPCODES);
+  switch (code) {
+      case EX_IRQ:
+        sig = SIGINT;
+        break;
+      case EX_IBE:
+        sig = SIGBUS;
+        break;
+      case EX_DBE:
+        sig = SIGBUS;
+        break;
+      case EX_SYS:
+        /* should not be seen */
+        KASSERT(0);
+        sig = SIGABRT;
+        break;
+      case EX_MOD: // Write these.
+      case EX_TLBL:
+      case EX_TLBS:
+        sig = SIGSEGV;
+        break;
+      case EX_ADEL: // Write these.
+      case EX_ADES:
+        sig = SIGBUS;
+        break;
+      case EX_BP:
+        sig = SIGTRAP;
+        break;
+      case EX_RI:
+        sig = SIGILL;
+        break;
+      case EX_CPU:
+        sig = SIGSEGV;
+        break;
+      case EX_OVF:
+        sig = SIGFPE;
+        break;
+      default:
+        sig = SIGKILL;
+        break;
+  }
+
+  /*
+   * You will probably want to change this.
+   */
+
+  kprintf("Fatal user mode trap %u sig %d (%s, epc 0x%x, vaddr 0x%x)\n",
+    code, sig, trapcodenames[code], epc, vaddr);
+  panic("I don't know how to handle this\n");
 }
 
 /*
@@ -125,225 +134,225 @@ kill_curthread(vaddr_t epc, unsigned code, vaddr_t vaddr)
 void
 mips_trap(struct trapframe *tf)
 {
-	uint32_t code;
-	bool isutlb, iskern;
-	int spl;
-
-	/* The trap frame is supposed to be 37 registers long. */
-	KASSERT(sizeof(struct trapframe)==(37*4));
-
-	/*
-	 * Extract the exception code info from the register fields.
-	 */
-	code = (tf->tf_cause & CCA_CODE) >> CCA_CODESHIFT;
-	isutlb = (tf->tf_cause & CCA_UTLB) != 0;
-	iskern = (tf->tf_status & CST_KUp) == 0;
-
-	KASSERT(code < NTRAPCODES);
-
-	/* Make sure we haven't run off our stack */
-	if (curthread != NULL && curthread->t_stack != NULL) {
-		KASSERT((vaddr_t)tf > (vaddr_t)curthread->t_stack);
-		KASSERT((vaddr_t)tf < (vaddr_t)(curthread->t_stack
-						+ STACK_SIZE));
-	}
-
-	/* Interrupt? Call the interrupt handler and return. */
-	if (code == EX_IRQ) {
-		int old_in;
-		bool doadjust;
-
-		old_in = curthread->t_in_interrupt;
-		curthread->t_in_interrupt = 1;
-
-		/*
-		 * The processor has turned interrupts off; if the
-		 * currently recorded interrupt state is interrupts on
-		 * (spl of 0), adjust the recorded state to match, and
-		 * restore after processing the interrupt.
-		 *
-		 * How can we get an interrupt if the recorded state
-		 * is interrupts off? Well, as things currently stand
-		 * when the CPU finishes idling it flips interrupts on
-		 * and off to allow things to happen, but leaves
-		 * curspl high while doing so.
-		 *
-		 * While we're here, assert that the interrupt
-		 * handling code hasn't leaked a spinlock or an
-		 * splhigh().
-		 */
-
-		if (curthread->t_curspl == 0) {
-			KASSERT(curthread->t_curspl == 0);
-			KASSERT(curthread->t_iplhigh_count == 0);
-			curthread->t_curspl = IPL_HIGH;
-			curthread->t_iplhigh_count++;
-			doadjust = true;
-		}
-		else {
-			doadjust = false;
-		}
-
-		mainbus_interrupt(tf);
-
-		if (doadjust) {
-			KASSERT(curthread->t_curspl == IPL_HIGH);
-			KASSERT(curthread->t_iplhigh_count == 1);
-			curthread->t_iplhigh_count--;
-			curthread->t_curspl = 0;
-		}
-
-		curthread->t_in_interrupt = old_in;
-		goto done2;
-	}
-
-	/*
-	 * The processor turned interrupts off when it took the trap.
-	 *
-	 * While we're in the kernel, and not actually handling an
-	 * interrupt, restore the interrupt state to where it was in
-	 * the previous context, which may be low (interrupts on).
-	 *
-	 * Do this by forcing splhigh(), which may do a redundant
-	 * cpu_irqoff() but forces the stored MI interrupt state into
-	 * sync, then restoring the previous state.
-	 */
-	spl = splhigh();
-	splx(spl);
-
-	/* Syscall? Call the syscall handler and return. */
-	if (code == EX_SYS) {
-		/* Interrupts should have been on while in user mode. */
-		KASSERT(curthread->t_curspl == 0);
-		KASSERT(curthread->t_iplhigh_count == 0);
-
-		DEBUG(DB_SYSCALL, "syscall: #%d, args %x %x %x %x\n", 
-		      tf->tf_v0, tf->tf_a0, tf->tf_a1, tf->tf_a2, tf->tf_a3);
-
-		syscall(tf);
-		goto done;
-	}
-
-	/*
-	 * Ok, it wasn't any of the really easy cases.
-	 * Call vm_fault on the TLB exceptions.
-	 * Panic on the bus error exceptions.
-	 */
-	switch (code) {
-	case EX_MOD:
-		if (vm_fault(VM_FAULT_READONLY, tf->tf_vaddr)==0) {
-			goto done;
-		}
-		break;
-	case EX_TLBL:
-		if (vm_fault(VM_FAULT_READ, tf->tf_vaddr)==0) {
-			goto done;
-		}
-		break;
-	case EX_TLBS:
-		if (vm_fault(VM_FAULT_WRITE, tf->tf_vaddr)==0) {
-			goto done;
-		}
-		break;
-	case EX_IBE:
-	case EX_DBE:
-		/*
-		 * This means you loaded invalid TLB entries, or 
-		 * touched invalid parts of the direct-mapped 
-		 * segments. These are serious kernel errors, so
-		 * panic.
-		 * 
-		 * The MIPS won't even tell you what invalid address
-		 * caused the bus error.
-		 */
-		panic("Bus error exception, PC=0x%x\n", tf->tf_epc);
-		break;
-	}
-
-	/*
-	 * If we get to this point, it's a fatal fault - either it's
-	 * one of the other exceptions, like illegal instruction, or
-	 * it was a page fault we couldn't handle.
-	 */
-
-	if (!iskern) {
-		/*
-		 * Fatal fault in user mode.
-		 * Kill the current user process.
-		 */
-		kill_curthread(tf->tf_epc, code, tf->tf_vaddr);
-		goto done;
-	}
-
-	/*
-	 * Fatal fault in kernel mode.
-	 *
-	 * If pcb_badfaultfunc is set, we do not panic; badfaultfunc is
-	 * set by copyin/copyout and related functions to signify that
-	 * the addresses they're accessing are userlevel-supplied and
-	 * not trustable. What we actually want to do is resume
-	 * execution at the function pointed to by badfaultfunc. That's 
-	 * going to be "copyfail" (see copyinout.c), which longjmps 
-	 * back to copyin/copyout or wherever and returns EFAULT.
-	 *
-	 * Note that we do not just *call* this function, because that
-	 * won't necessarily do anything. We want the control flow
-	 * that is currently executing in copyin (or whichever), and
-	 * is stopped while we process the exception, to *teleport* to
-	 * copyfail.
-	 *
-	 * This is accomplished by changing tf->tf_epc and returning
-	 * from the exception handler.
-	 */
-
-	if (curthread != NULL &&
-	    curthread->t_machdep.tm_badfaultfunc != NULL) {
-		tf->tf_epc = (vaddr_t) curthread->t_machdep.tm_badfaultfunc;
-		goto done;
-	}
-
-	/*
-	 * Really fatal kernel-mode fault.
-	 */
-
-	kprintf("panic: Fatal exception %u (%s) in kernel mode\n", code,
-		trapcodenames[code]);
-	kprintf("panic: EPC 0x%x, exception vaddr 0x%x\n", 
-		tf->tf_epc, tf->tf_vaddr);
-
-	panic("I can't handle this... I think I'll just die now...\n");
+  uint32_t code;
+  bool isutlb, iskern;
+  int spl;
+
+  /* The trap frame is supposed to be 37 registers long. */
+  KASSERT(sizeof(struct trapframe)==(37*4));
+
+  /*
+   * Extract the exception code info from the register fields.
+   */
+  code = (tf->tf_cause & CCA_CODE) >> CCA_CODESHIFT;
+  isutlb = (tf->tf_cause & CCA_UTLB) != 0;
+  iskern = (tf->tf_status & CST_KUp) == 0;
+
+  KASSERT(code < NTRAPCODES);
+
+  /* Make sure we haven't run off our stack */
+  if (curthread != NULL && curthread->t_stack != NULL) {
+    KASSERT((vaddr_t)tf > (vaddr_t)curthread->t_stack);
+    KASSERT((vaddr_t)tf < (vaddr_t)(curthread->t_stack
+            + STACK_SIZE));
+  }
+
+  /* Interrupt? Call the interrupt handler and return. */
+  if (code == EX_IRQ) {
+    int old_in;
+    bool doadjust;
+
+    old_in = curthread->t_in_interrupt;
+    curthread->t_in_interrupt = 1;
+
+    /*
+     * The processor has turned interrupts off; if the
+     * currently recorded interrupt state is interrupts on
+     * (spl of 0), adjust the recorded state to match, and
+     * restore after processing the interrupt.
+     *
+     * How can we get an interrupt if the recorded state
+     * is interrupts off? Well, as things currently stand
+     * when the CPU finishes idling it flips interrupts on
+     * and off to allow things to happen, but leaves
+     * curspl high while doing so.
+     *
+     * While we're here, assert that the interrupt
+     * handling code hasn't leaked a spinlock or an
+     * splhigh().
+     */
+
+    if (curthread->t_curspl == 0) {
+      KASSERT(curthread->t_curspl == 0);
+      KASSERT(curthread->t_iplhigh_count == 0);
+      curthread->t_curspl = IPL_HIGH;
+      curthread->t_iplhigh_count++;
+      doadjust = true;
+    }
+    else {
+      doadjust = false;
+    }
+
+    mainbus_interrupt(tf);
+
+    if (doadjust) {
+      KASSERT(curthread->t_curspl == IPL_HIGH);
+      KASSERT(curthread->t_iplhigh_count == 1);
+      curthread->t_iplhigh_count--;
+      curthread->t_curspl = 0;
+    }
+
+    curthread->t_in_interrupt = old_in;
+    goto done2;
+  }
+
+  /*
+   * The processor turned interrupts off when it took the trap.
+   *
+   * While we're in the kernel, and not actually handling an
+   * interrupt, restore the interrupt state to where it was in
+   * the previous context, which may be low (interrupts on).
+   *
+   * Do this by forcing splhigh(), which may do a redundant
+   * cpu_irqoff() but forces the stored MI interrupt state into
+   * sync, then restoring the previous state.
+   */
+  spl = splhigh();
+  splx(spl);
+
+  /* Syscall? Call the syscall handler and return. */
+  if (code == EX_SYS) {
+    /* Interrupts should have been on while in user mode. */
+    KASSERT(curthread->t_curspl == 0);
+    KASSERT(curthread->t_iplhigh_count == 0);
+
+    DEBUG(DB_SYSCALL, "syscall: #%d, args %x %x %x %x\n", 
+          tf->tf_v0, tf->tf_a0, tf->tf_a1, tf->tf_a2, tf->tf_a3);
+
+    syscall(tf);
+    goto done;
+  }
+
+  /*
+   * Ok, it wasn't any of the really easy cases.
+   * Call vm_fault on the TLB exceptions.
+   * Panic on the bus error exceptions.
+   */
+  switch (code) {
+  case EX_MOD:
+    if (vm_fault(VM_FAULT_READONLY, tf->tf_vaddr)==0) {
+      goto done;
+    }
+    break;
+  case EX_TLBL:
+    if (vm_fault(VM_FAULT_READ, tf->tf_vaddr)==0) {
+      goto done;
+    }
+    break;
+  case EX_TLBS:
+    if (vm_fault(VM_FAULT_WRITE, tf->tf_vaddr)==0) {
+      goto done;
+    }
+    break;
+  case EX_IBE:
+  case EX_DBE:
+    /*
+     * This means you loaded invalid TLB entries, or 
+     * touched invalid parts of the direct-mapped 
+     * segments. These are serious kernel errors, so
+     * panic.
+     * 
+     * The MIPS won't even tell you what invalid address
+     * caused the bus error.
+     */
+    panic("Bus error exception, PC=0x%x\n", tf->tf_epc);
+    break;
+  }
+
+  /*
+   * If we get to this point, it's a fatal fault - either it's
+   * one of the other exceptions, like illegal instruction, or
+   * it was a page fault we couldn't handle.
+   */
+
+  if (!iskern) {
+    /*
+     * Fatal fault in user mode.
+     * Kill the current user process.
+     */
+    kill_curthread(tf->tf_epc, code, tf->tf_vaddr);
+    goto done;
+  }
+
+  /*
+   * Fatal fault in kernel mode.
+   *
+   * If pcb_badfaultfunc is set, we do not panic; badfaultfunc is
+   * set by copyin/copyout and related functions to signify that
+   * the addresses they're accessing are userlevel-supplied and
+   * not trustable. What we actually want to do is resume
+   * execution at the function pointed to by badfaultfunc. That's 
+   * going to be "copyfail" (see copyinout.c), which longjmps 
+   * back to copyin/copyout or wherever and returns EFAULT.
+   *
+   * Note that we do not just *call* this function, because that
+   * won't necessarily do anything. We want the control flow
+   * that is currently executing in copyin (or whichever), and
+   * is stopped while we process the exception, to *teleport* to
+   * copyfail.
+   *
+   * This is accomplished by changing tf->tf_epc and returning
+   * from the exception handler.
+   */
+
+  if (curthread != NULL &&
+      curthread->t_machdep.tm_badfaultfunc != NULL) {
+    tf->tf_epc = (vaddr_t) curthread->t_machdep.tm_badfaultfunc;
+    goto done;
+  }
+
+  /*
+   * Really fatal kernel-mode fault.
+   */
+
+  kprintf("panic: Fatal exception %u (%s) in kernel mode\n", code,
+    trapcodenames[code]);
+  kprintf("panic: EPC 0x%x, exception vaddr 0x%x\n", 
+    tf->tf_epc, tf->tf_vaddr);
+
+  panic("I can't handle this... I think I'll just die now...\n");
 
  done:
-	/*
-	 * Turn interrupts off on the processor, without affecting the
-	 * stored interrupt state.
-	 */
-	cpu_irqoff();
+  /*
+   * Turn interrupts off on the processor, without affecting the
+   * stored interrupt state.
+   */
+  cpu_irqoff();
  done2:
 
-	/*
-	 * The boot thread can get here (e.g. on interrupt return) but
-	 * since it doesn't go to userlevel, it can't be returning to
-	 * userlevel, so there's no need to set cputhreads[] and
-	 * cpustacks[]. Just return.
-	 */
-	if (curthread->t_stack == NULL) {
-		return;
-	}
-
-	cputhreads[curcpu->c_number] = (vaddr_t)curthread;
-	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
-
-	/*
-	 * This assertion will fail if either
-	 *   (1) curthread->t_stack is corrupted, or
-	 *   (2) the trap frame is somehow on the wrong kernel stack.
-	 *
-	 * If cpustacks[] is corrupted, the next trap back to the
-	 * kernel will (most likely) hang the system, so it's better
-	 * to find out now.
-	 */
-	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
+  /*
+   * The boot thread can get here (e.g. on interrupt return) but
+   * since it doesn't go to userlevel, it can't be returning to
+   * userlevel, so there's no need to set cputhreads[] and
+   * cpustacks[]. Just return.
+   */
+  if (curthread->t_stack == NULL) {
+    return;
+  }
+
+  cputhreads[curcpu->c_number] = (vaddr_t)curthread;
+  cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
+
+  /*
+   * This assertion will fail if either
+   *   (1) curthread->t_stack is corrupted, or
+   *   (2) the trap frame is somehow on the wrong kernel stack.
+   *
+   * If cpustacks[] is corrupted, the next trap back to the
+   * kernel will (most likely) hang the system, so it's better
+   * to find out now.
+   */
+  KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
 }
 
 /*
@@ -367,39 +376,39 @@ void
 mips_usermode(struct trapframe *tf)
 {
 
-	/*
-	 * Interrupts should be off within the kernel while entering
-	 * user mode. However, while in user mode, interrupts should
-	 * be on. To interact properly with the spl-handling logic
-	 * above, we explicitly call spl0() and then call cpu_irqoff().
-	 */
-	spl0();
-	cpu_irqoff();
-
-	cputhreads[curcpu->c_number] = (vaddr_t)curthread;
-	cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
-
-	/*
-	 * This assertion will fail if either
-	 *   (1) cpustacks[] is corrupted, or
-	 *   (2) the trap frame is not on our own kernel stack, or
-	 *   (3) the boot thread tries to enter user mode.
-	 *
-	 * If cpustacks[] is corrupted, the next trap back to the
-	 * kernel will (most likely) hang the system, so it's better
-	 * to find out now.
-	 *
-	 * It's necessary for the trap frame used here to be on the
-	 * current thread's own stack. It cannot correctly be on
-	 * either another thread's stack or in the kernel heap.
-	 * (Exercise: why?)
-	 */
-	KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
-
-	/*
-	 * This actually does it. See exception.S.
-	 */
-	asm_usermode(tf);
+  /*
+   * Interrupts should be off within the kernel while entering
+   * user mode. However, while in user mode, interrupts should
+   * be on. To interact properly with the spl-handling logic
+   * above, we explicitly call spl0() and then call cpu_irqoff().
+   */
+  spl0();
+  cpu_irqoff();
+
+  cputhreads[curcpu->c_number] = (vaddr_t)curthread;
+  cpustacks[curcpu->c_number] = (vaddr_t)curthread->t_stack + STACK_SIZE;
+
+  /*
+   * This assertion will fail if either
+   *   (1) cpustacks[] is corrupted, or
+   *   (2) the trap frame is not on our own kernel stack, or
+   *   (3) the boot thread tries to enter user mode.
+   *
+   * If cpustacks[] is corrupted, the next trap back to the
+   * kernel will (most likely) hang the system, so it's better
+   * to find out now.
+   *
+   * It's necessary for the trap frame used here to be on the
+   * current thread's own stack. It cannot correctly be on
+   * either another thread's stack or in the kernel heap.
+   * (Exercise: why?)
+   */
+  KASSERT(SAME_STACK(cpustacks[curcpu->c_number]-1, (vaddr_t)tf));
+
+  /*
+   * This actually does it. See exception.S.
+   */
+  asm_usermode(tf);
 }
 
 /*
@@ -417,15 +426,15 @@ mips_usermode(struct trapframe *tf)
 void
 enter_new_process(int argc, userptr_t argv, vaddr_t stack, vaddr_t entry)
 {
-	struct trapframe tf;
+  struct trapframe tf;
 
-	bzero(&tf, sizeof(tf));
+  bzero(&tf, sizeof(tf));
 
-	tf.tf_status = CST_IRQMASK | CST_IEp | CST_KUp;
-	tf.tf_epc = entry;
-	tf.tf_a0 = argc;
-	tf.tf_a1 = (vaddr_t)argv;
-	tf.tf_sp = stack;
+  tf.tf_status = CST_IRQMASK | CST_IEp | CST_KUp;
+  tf.tf_epc = entry;
+  tf.tf_a0 = argc;
+  tf.tf_a1 = (vaddr_t)argv;
+  tf.tf_sp = stack;
 
-	mips_usermode(&tf);
+  mips_usermode(&tf);
 }
diff --git a/kern/arch/mips/syscall/syscall.c b/kern/arch/mips/syscall/syscall.c
index 0f773bd..37821d7 100644
--- a/kern/arch/mips/syscall/syscall.c
+++ b/kern/arch/mips/syscall/syscall.c
@@ -35,7 +35,9 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include <copyinout.h>
 
+#include <syscall.h>
 
 /*
  * System call dispatcher.
@@ -80,7 +82,8 @@ syscall(struct trapframe *tf)
 {
 	int callno;
 	int32_t retval;
-	int err;
+	int err, whence;
+  off_t pos, ret;
 
 	KASSERT(curthread != NULL);
 	KASSERT(curthread->t_curspl == 0);
@@ -88,6 +91,7 @@ syscall(struct trapframe *tf)
 
 	callno = tf->tf_v0;
 
+
 	/*
 	 * Initialize retval to 0. Many of the system calls don't
 	 * really return a value, just 0 for success and -1 on
@@ -101,15 +105,89 @@ syscall(struct trapframe *tf)
 
 	switch (callno) {
 	    case SYS_reboot:
-		err = sys_reboot(tf->tf_a0);
-		break;
+		    err = sys_reboot(tf->tf_a0);
+    		break;
 
 	    case SYS___time:
-		err = sys___time((userptr_t)tf->tf_a0,
-				 (userptr_t)tf->tf_a1);
-		break;
+		    err = sys___time((userptr_t)tf->tf_a0, (userptr_t)tf->tf_a1);
+    		break;
 
 	    /* Add stuff here */
+
+      case SYS_open:
+        err = sys_open((char *) tf->tf_a0, tf->tf_a1, tf->tf_a2, &retval);
+        break;
+
+      case SYS_close:
+        err = sys_close(tf->tf_a0);
+        break;
+
+      case SYS_read:
+        err = sys_read(tf->tf_a0, (void *)tf->tf_a1, tf->tf_a2, &retval);
+        break;
+
+      case SYS_write:
+        err = sys_write(tf->tf_a0, (void *)tf->tf_a1, tf->tf_a2, &retval);
+        break;
+
+      case SYS_dup2:
+        err = sys_dup2(tf->tf_a0, tf->tf_a1);
+        break;
+
+      case SYS_chdir:
+        err = sys_chdir((const char *)tf->tf_a0);
+        break;
+
+      case SYS___getcwd:
+        err = sys__getcwd((char *)tf->tf_a0, tf->tf_a1);
+        break;
+
+      case SYS_lseek:
+        pos = 0;
+        pos |= tf->tf_a2;
+        pos <<= 32;
+        pos |= tf->tf_a3;
+
+        if (copyin((void *)(tf->tf_sp + 16), (userptr_t *)&whence, sizeof(int)))
+          err = 1;
+
+        err = sys_lseek(tf->tf_a0, pos, whence, &ret);
+
+        if (!err) {
+          // Get the high 32 bits.
+          retval = ret >> 32;
+          // Get the low 32 bits. Remember how a union works.
+          tf->tf_v1 = ret;
+        }
+        break;
+
+        // Process System Calls.
+
+        case SYS_fork:
+          err = sys_fork(tf, &retval);
+          break;
+
+        case SYS_getpid:
+          err = 0;
+          retval = sys_getpid();
+          break;
+
+        case SYS_waitpid:
+          err = sys_waitpid(tf->tf_a0, (int *)tf->tf_a1, tf->tf_a2, &retval);
+          break;
+
+        case SYS__exit:
+          err = 0;
+          retval = 0;
+          sys__exit(tf->tf_a0);
+          break;
+
+         case SYS_execv:
+          err = sys_execv((const char *)tf->tf_a0, (char **)tf->tf_a1);
+          retval = 0;
+          break;
+
+      /* End add stuff */
  
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
diff --git a/kern/arch/mips/vm/dumbvm.c b/kern/arch/mips/vm/dumbvm.c
index ca9992a..8ff9239 100644
--- a/kern/arch/mips/vm/dumbvm.c
+++ b/kern/arch/mips/vm/dumbvm.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -56,319 +56,319 @@ static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
 void
 vm_bootstrap(void)
 {
-	/* Do nothing. */
+  /* Do nothing. */
 }
 
 static
 paddr_t
 getppages(unsigned long npages)
 {
-	paddr_t addr;
+  paddr_t addr;
 
-	spinlock_acquire(&stealmem_lock);
+  spinlock_acquire(&stealmem_lock);
 
-	addr = ram_stealmem(npages);
-	
-	spinlock_release(&stealmem_lock);
-	return addr;
+  addr = ram_stealmem(npages);
+
+  spinlock_release(&stealmem_lock);
+  return addr;
 }
 
 /* Allocate/free some kernel-space virtual pages */
-vaddr_t 
+vaddr_t
 alloc_kpages(int npages)
 {
-	paddr_t pa;
-	pa = getppages(npages);
-	if (pa==0) {
-		return 0;
-	}
-	return PADDR_TO_KVADDR(pa);
+  paddr_t pa;
+  pa = getppages(npages);
+  if (pa==0) {
+    return 0;
+  }
+  return PADDR_TO_KVADDR(pa);
 }
 
-void 
+void
 free_kpages(vaddr_t addr)
 {
-	/* nothing - leak the memory. */
+  /* nothing - leak the memory. */
 
-	(void)addr;
+  (void)addr;
 }
 
 void
 vm_tlbshootdown_all(void)
 {
-	panic("dumbvm tried to do tlb shootdown?!\n");
+  panic("dumbvm tried to do tlb shootdown?!\n");
 }
 
 void
 vm_tlbshootdown(const struct tlbshootdown *ts)
 {
-	(void)ts;
-	panic("dumbvm tried to do tlb shootdown?!\n");
+  (void)ts;
+  panic("dumbvm tried to do tlb shootdown?!\n");
 }
 
 int
 vm_fault(int faulttype, vaddr_t faultaddress)
 {
-	vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
-	paddr_t paddr;
-	int i;
-	uint32_t ehi, elo;
-	struct addrspace *as;
-	int spl;
-
-	faultaddress &= PAGE_FRAME;
-
-	DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
-
-	switch (faulttype) {
-	    case VM_FAULT_READONLY:
-		/* We always create pages read-write, so we can't get this */
-		panic("dumbvm: got VM_FAULT_READONLY\n");
-	    case VM_FAULT_READ:
-	    case VM_FAULT_WRITE:
-		break;
-	    default:
-		return EINVAL;
-	}
-
-	as = curthread->t_addrspace;
-	if (as == NULL) {
-		/*
-		 * No address space set up. This is probably a kernel
-		 * fault early in boot. Return EFAULT so as to panic
-		 * instead of getting into an infinite faulting loop.
-		 */
-		return EFAULT;
-	}
-
-	/* Assert that the address space has been set up properly. */
-	KASSERT(as->as_vbase1 != 0);
-	KASSERT(as->as_pbase1 != 0);
-	KASSERT(as->as_npages1 != 0);
-	KASSERT(as->as_vbase2 != 0);
-	KASSERT(as->as_pbase2 != 0);
-	KASSERT(as->as_npages2 != 0);
-	KASSERT(as->as_stackpbase != 0);
-	KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
-	KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
-	KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
-	KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
-	KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
-
-	vbase1 = as->as_vbase1;
-	vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
-	vbase2 = as->as_vbase2;
-	vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
-	stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
-	stacktop = USERSTACK;
-
-	if (faultaddress >= vbase1 && faultaddress < vtop1) {
-		paddr = (faultaddress - vbase1) + as->as_pbase1;
-	}
-	else if (faultaddress >= vbase2 && faultaddress < vtop2) {
-		paddr = (faultaddress - vbase2) + as->as_pbase2;
-	}
-	else if (faultaddress >= stackbase && faultaddress < stacktop) {
-		paddr = (faultaddress - stackbase) + as->as_stackpbase;
-	}
-	else {
-		return EFAULT;
-	}
-
-	/* make sure it's page-aligned */
-	KASSERT((paddr & PAGE_FRAME) == paddr);
-
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
-
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_read(&ehi, &elo, i);
-		if (elo & TLBLO_VALID) {
-			continue;
-		}
-		ehi = faultaddress;
-		elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
-		DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
-		tlb_write(ehi, elo, i);
-		splx(spl);
-		return 0;
-	}
-
-	kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
-	splx(spl);
-	return EFAULT;
+  vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+  paddr_t paddr;
+  int i;
+  uint32_t ehi, elo;
+  struct addrspace *as;
+  int spl;
+
+  faultaddress &= PAGE_FRAME;
+
+  DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+  switch (faulttype) {
+      case VM_FAULT_READONLY:
+    /* We always create pages read-write, so we can't get this */
+    panic("dumbvm: got VM_FAULT_READONLY\n");
+      case VM_FAULT_READ:
+      case VM_FAULT_WRITE:
+    break;
+      default:
+    return EINVAL;
+  }
+
+  as = curthread->t_addrspace;
+  if (as == NULL) {
+    /*
+     * No address space set up. This is probably a kernel
+     * fault early in boot. Return EFAULT so as to panic
+     * instead of getting into an infinite faulting loop.
+     */
+    return EFAULT;
+  }
+
+  /* Assert that the address space has been set up properly. */
+  KASSERT(as->as_vbase1 != 0);
+  KASSERT(as->as_pbase1 != 0);
+  KASSERT(as->as_npages1 != 0);
+  KASSERT(as->as_vbase2 != 0);
+  KASSERT(as->as_pbase2 != 0);
+  KASSERT(as->as_npages2 != 0);
+  KASSERT(as->as_stackpbase != 0);
+  KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+  KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+  KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+  KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+  KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+  vbase1 = as->as_vbase1;
+  vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+  vbase2 = as->as_vbase2;
+  vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+  stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+  stacktop = USERSTACK;
+
+  if (faultaddress >= vbase1 && faultaddress < vtop1) {
+    paddr = (faultaddress - vbase1) + as->as_pbase1;
+  }
+  else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+    paddr = (faultaddress - vbase2) + as->as_pbase2;
+  }
+  else if (faultaddress >= stackbase && faultaddress < stacktop) {
+    paddr = (faultaddress - stackbase) + as->as_stackpbase;
+  }
+  else {
+    return EFAULT;
+  }
+
+  /* make sure it's page-aligned */
+  KASSERT((paddr & PAGE_FRAME) == paddr);
+
+  /* Disable interrupts on this CPU while frobbing the TLB. */
+  spl = splhigh();
+
+  for (i=0; i<NUM_TLB; i++) {
+    tlb_read(&ehi, &elo, i);
+    if (elo & TLBLO_VALID) {
+      continue;
+    }
+    ehi = faultaddress;
+    elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+    DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+    tlb_write(ehi, elo, i);
+    splx(spl);
+    return 0;
+  }
+
+  kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+  splx(spl);
+  return EFAULT;
 }
 
 struct addrspace *
 as_create(void)
 {
-	struct addrspace *as = kmalloc(sizeof(struct addrspace));
-	if (as==NULL) {
-		return NULL;
-	}
-
-	as->as_vbase1 = 0;
-	as->as_pbase1 = 0;
-	as->as_npages1 = 0;
-	as->as_vbase2 = 0;
-	as->as_pbase2 = 0;
-	as->as_npages2 = 0;
-	as->as_stackpbase = 0;
-
-	return as;
+  struct addrspace *as = kmalloc(sizeof(struct addrspace));
+  if (as==NULL) {
+    return NULL;
+  }
+
+  as->as_vbase1 = 0;
+  as->as_pbase1 = 0;
+  as->as_npages1 = 0;
+  as->as_vbase2 = 0;
+  as->as_pbase2 = 0;
+  as->as_npages2 = 0;
+  as->as_stackpbase = 0;
+
+  return as;
 }
 
 void
 as_destroy(struct addrspace *as)
 {
-	kfree(as);
+  kfree(as);
 }
 
 void
 as_activate(struct addrspace *as)
 {
-	int i, spl;
+  int i, spl;
 
-	(void)as;
+  (void)as;
 
-	/* Disable interrupts on this CPU while frobbing the TLB. */
-	spl = splhigh();
+  /* Disable interrupts on this CPU while frobbing the TLB. */
+  spl = splhigh();
 
-	for (i=0; i<NUM_TLB; i++) {
-		tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
-	}
+  for (i=0; i<NUM_TLB; i++) {
+    tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+  }
 
-	splx(spl);
+  splx(spl);
 }
 
 int
 as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
-		 int readable, int writeable, int executable)
+     int readable, int writeable, int executable)
 {
-	size_t npages; 
-
-	/* Align the region. First, the base... */
-	sz += vaddr & ~(vaddr_t)PAGE_FRAME;
-	vaddr &= PAGE_FRAME;
-
-	/* ...and now the length. */
-	sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
-
-	npages = sz / PAGE_SIZE;
-
-	/* We don't use these - all pages are read-write */
-	(void)readable;
-	(void)writeable;
-	(void)executable;
-
-	if (as->as_vbase1 == 0) {
-		as->as_vbase1 = vaddr;
-		as->as_npages1 = npages;
-		return 0;
-	}
-
-	if (as->as_vbase2 == 0) {
-		as->as_vbase2 = vaddr;
-		as->as_npages2 = npages;
-		return 0;
-	}
-
-	/*
-	 * Support for more than two regions is not available.
-	 */
-	kprintf("dumbvm: Warning: too many regions\n");
-	return EUNIMP;
+  size_t npages; 
+
+  /* Align the region. First, the base... */
+  sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+  vaddr &= PAGE_FRAME;
+
+  /* ...and now the length. */
+  sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+  npages = sz / PAGE_SIZE;
+
+  /* We don't use these - all pages are read-write */
+  (void)readable;
+  (void)writeable;
+  (void)executable;
+
+  if (as->as_vbase1 == 0) {
+    as->as_vbase1 = vaddr;
+    as->as_npages1 = npages;
+    return 0;
+  }
+
+  if (as->as_vbase2 == 0) {
+    as->as_vbase2 = vaddr;
+    as->as_npages2 = npages;
+    return 0;
+  }
+
+  /*
+   * Support for more than two regions is not available.
+   */
+  kprintf("dumbvm: Warning: too many regions\n");
+  return EUNIMP;
 }
 
 static
 void
 as_zero_region(paddr_t paddr, unsigned npages)
 {
-	bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+  bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
 }
 
 int
 as_prepare_load(struct addrspace *as)
 {
-	KASSERT(as->as_pbase1 == 0);
-	KASSERT(as->as_pbase2 == 0);
-	KASSERT(as->as_stackpbase == 0);
-
-	as->as_pbase1 = getppages(as->as_npages1);
-	if (as->as_pbase1 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_pbase2 = getppages(as->as_npages2);
-	if (as->as_pbase2 == 0) {
-		return ENOMEM;
-	}
-
-	as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
-	if (as->as_stackpbase == 0) {
-		return ENOMEM;
-	}
-	
-	as_zero_region(as->as_pbase1, as->as_npages1);
-	as_zero_region(as->as_pbase2, as->as_npages2);
-	as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
-
-	return 0;
+  KASSERT(as->as_pbase1 == 0);
+  KASSERT(as->as_pbase2 == 0);
+  KASSERT(as->as_stackpbase == 0);
+
+  as->as_pbase1 = getppages(as->as_npages1);
+  if (as->as_pbase1 == 0) {
+    return ENOMEM;
+  }
+
+  as->as_pbase2 = getppages(as->as_npages2);
+  if (as->as_pbase2 == 0) {
+    return ENOMEM;
+  }
+
+  as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+  if (as->as_stackpbase == 0) {
+    return ENOMEM;
+  }
+  
+  as_zero_region(as->as_pbase1, as->as_npages1);
+  as_zero_region(as->as_pbase2, as->as_npages2);
+  as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+
+  return 0;
 }
 
 int
 as_complete_load(struct addrspace *as)
 {
-	(void)as;
-	return 0;
+  (void)as;
+  return 0;
 }
 
 int
 as_define_stack(struct addrspace *as, vaddr_t *stackptr)
 {
-	KASSERT(as->as_stackpbase != 0);
+  KASSERT(as->as_stackpbase != 0);
 
-	*stackptr = USERSTACK;
-	return 0;
+  *stackptr = USERSTACK;
+  return 0;
 }
 
 int
 as_copy(struct addrspace *old, struct addrspace **ret)
 {
-	struct addrspace *new;
-
-	new = as_create();
-	if (new==NULL) {
-		return ENOMEM;
-	}
-
-	new->as_vbase1 = old->as_vbase1;
-	new->as_npages1 = old->as_npages1;
-	new->as_vbase2 = old->as_vbase2;
-	new->as_npages2 = old->as_npages2;
-
-	/* (Mis)use as_prepare_load to allocate some physical memory. */
-	if (as_prepare_load(new)) {
-		as_destroy(new);
-		return ENOMEM;
-	}
-
-	KASSERT(new->as_pbase1 != 0);
-	KASSERT(new->as_pbase2 != 0);
-	KASSERT(new->as_stackpbase != 0);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase1),
-		old->as_npages1*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
-		(const void *)PADDR_TO_KVADDR(old->as_pbase2),
-		old->as_npages2*PAGE_SIZE);
-
-	memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
-		(const void *)PADDR_TO_KVADDR(old->as_stackpbase),
-		DUMBVM_STACKPAGES*PAGE_SIZE);
-	
-	*ret = new;
-	return 0;
+  struct addrspace *new;
+
+  new = as_create();
+  if (new==NULL) {
+    return ENOMEM;
+  }
+
+  new->as_vbase1 = old->as_vbase1;
+  new->as_npages1 = old->as_npages1;
+  new->as_vbase2 = old->as_vbase2;
+  new->as_npages2 = old->as_npages2;
+
+  /* (Mis)use as_prepare_load to allocate some physical memory. */
+  if (as_prepare_load(new)) {
+    as_destroy(new);
+    return ENOMEM;
+  }
+
+  KASSERT(new->as_pbase1 != 0);
+  KASSERT(new->as_pbase2 != 0);
+  KASSERT(new->as_stackpbase != 0);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+    (const void *)PADDR_TO_KVADDR(old->as_pbase1),
+    old->as_npages1*PAGE_SIZE);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+    (const void *)PADDR_TO_KVADDR(old->as_pbase2),
+    old->as_npages2*PAGE_SIZE);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+    (const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+    DUMBVM_STACKPAGES*PAGE_SIZE);
+  
+  *ret = new;
+  return 0;
 }
diff --git a/kern/arch/mips/vm/ram.c b/kern/arch/mips/vm/ram.c
index c675e73..5716853 100644
--- a/kern/arch/mips/vm/ram.c
+++ b/kern/arch/mips/vm/ram.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -45,32 +45,32 @@ static paddr_t lastpaddr;   /* one past end of last free physical page */
 void
 ram_bootstrap(void)
 {
-	size_t ramsize;
-	
-	/* Get size of RAM. */
-	ramsize = mainbus_ramsize();
-
-	/*
-	 * This is the same as the last physical address, as long as
-	 * we have less than 508 megabytes of memory. If we had more,
-	 * various annoying properties of the MIPS architecture would
-	 * force the RAM to be discontiguous. This is not a case we 
-	 * are going to worry about.
-	 */
-	if (ramsize > 508*1024*1024) {
-		ramsize = 508*1024*1024;
-	}
-
-	lastpaddr = ramsize;
-
-	/* 
-	 * Get first free virtual address from where start.S saved it.
-	 * Convert to physical address.
-	 */
-	firstpaddr = firstfree - MIPS_KSEG0;
-
-	kprintf("%uk physical memory available\n", 
-		(lastpaddr-firstpaddr)/1024);
+  size_t ramsize;
+
+  /* Get size of RAM. */
+  ramsize = mainbus_ramsize();
+
+  /*
+   * This is the same as the last physical address, as long as
+   * we have less than 508 megabytes of memory. If we had more,
+   * various annoying properties of the MIPS architecture would
+   * force the RAM to be discontiguous. This is not a case we 
+   * are going to worry about.
+   */
+  if (ramsize > 508*1024*1024) {
+    ramsize = 508*1024*1024;
+  }
+
+  lastpaddr = ramsize;
+
+  /* 
+   * Get first free virtual address from where start.S saved it.
+   * Convert to physical address.
+   */
+  firstpaddr = firstfree - MIPS_KSEG0;
+
+  kprintf("%uk physical memory available\n", 
+    (lastpaddr-firstpaddr)/1024);
 }
 
 /*
@@ -94,19 +94,19 @@ ram_bootstrap(void)
 paddr_t
 ram_stealmem(unsigned long npages)
 {
-	size_t size;
-	paddr_t paddr;
+  size_t size;
+  paddr_t paddr;
 
-	size = npages * PAGE_SIZE;
+  size = npages * PAGE_SIZE;
 
-	if (firstpaddr + size > lastpaddr) {
-		return 0;
-	}
+  if (firstpaddr + size > lastpaddr) {
+    return 0;
+  }
 
-	paddr = firstpaddr;
-	firstpaddr += size;
+  paddr = firstpaddr;
+  firstpaddr += size;
 
-	return paddr;
+  return paddr;
 }
 
 /*
@@ -120,7 +120,7 @@ ram_stealmem(unsigned long npages)
 void
 ram_getsize(paddr_t *lo, paddr_t *hi)
 {
-	*lo = firstpaddr;
-	*hi = lastpaddr;
-	firstpaddr = lastpaddr = 0;
+  *lo = firstpaddr;
+  *hi = lastpaddr;
+  firstpaddr = lastpaddr = 0;
 }
diff --git a/kern/arch/mips/vm/theomegavm.c b/kern/arch/mips/vm/theomegavm.c
new file mode 100644
index 0000000..f91f67c
--- /dev/null
+++ b/kern/arch/mips/vm/theomegavm.c
@@ -0,0 +1,472 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <thread.h>
+#include <current.h>
+#include <mips/tlb.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <synch.h>
+
+// The last VM you'll ever need.
+
+/* under dumbvm, always have 48k of user stack */
+#define DUMBVM_STACKPAGES    12
+
+/*
+ * Wrap rma_stealmem in a spinlock.
+ */
+//static struct spinlock stealmem_lock = SPINLOCK_INITIALIZER;
+
+// startaddr, freeaddr is the coremap. freeaddr, endaddr is the
+// coremap.
+static paddr_t startaddr, endaddr, freeaddr;
+
+static struct Page *coremap;
+
+static int bootstrap = 0;
+
+static unsigned long long num_pages;
+
+static struct lock *coremaplock;
+
+// Setup Mon flying coremap, map, map, map, map.
+// The next free page is at curfreeaddr + PAGE_SIZE.
+void vm_bootstrap(void) {
+
+  unsigned long long i;
+
+  ram_getsize(&startaddr, &endaddr);
+
+  num_pages = (endaddr - startaddr) / PAGE_SIZE;
+
+  freeaddr = startaddr + num_pages * sizeof(struct Page);
+  freeaddr = ROUNDUP(freeaddr, PAGE_SIZE);
+
+  KASSERT((freeaddr & PAGE_FRAME) == freeaddr);
+
+  // Setup the coremap.
+  coremap = (struct Page *)PADDR_TO_KVADDR(startaddr);
+  for (i = 0; i < num_pages; i++) {
+    coremap[i].addrspace = NULL;
+    coremap[i].paddr = freeaddr + PAGE_SIZE * i;
+    coremap[i].vaddr = PADDR_TO_KVADDR(coremap[i].paddr);
+    coremap[i].state = FREE;
+    coremap[i].timestamp = 0; // For now. Change this later.
+    coremap[i].pagecount = 0;
+  }
+
+  coremaplock = lock_create("Coremap Lock");
+
+  bootstrap = 1;
+}
+
+paddr_t getppages(unsigned long npages, int state) {
+
+  paddr_t newaddr;
+  int flag;
+  unsigned long count, i, index, j;
+
+
+  if (bootstrap == 0) {
+    newaddr = ram_stealmem(npages);
+    return newaddr;
+  }
+
+  //spinlock_acquire(&stealmem_lock);
+  lock_acquire(coremaplock);
+
+  flag = 0; count = 0; index = 0; j = 0;
+  for (i = 0; i < num_pages; i++) {
+
+    if (count == npages) {
+      break;
+    }
+
+    if (coremap[i].state == FREE) {
+      if (flag == 0) {
+        index = i;
+        flag = 1;
+      }
+      count++;
+    }
+    else if (coremap[i].state == DIRTY || coremap[i].state == CLEAN || coremap[i].state == FIXED) {
+      flag = 0;
+      count = 0;
+    }
+
+  }
+
+  /*flag = 0;
+  for (i = 0; i < num_pages - npages; i++) {
+    for (j = i; j < i + npages; j++) {
+      if (coremap[i].state == FREE && flag == 0) {
+        index = j;
+        flag = 1;
+      }
+      else {
+        flag = 0;
+        count = 0;
+        break;
+      }
+      count++;
+    }
+  }*/
+
+  if (count != npages) {
+    return 0;
+  }
+
+  coremap[index].pagecount = npages;
+  newaddr = coremap[index].paddr;
+
+  for (i = index; i < index + npages; i++) {
+    coremap[i].state = state; // Update addrspace. Update timestamp.
+    bzero((void *)coremap[i].vaddr, PAGE_SIZE);
+  }
+
+  //spinlock_release(&stealmem_lock);
+  lock_release(coremaplock);
+
+  return newaddr;
+}
+
+/* Allocate/free some kernel-space virtual pages */
+vaddr_t alloc_kpages(int npages)
+{
+  paddr_t pa;
+
+  pa = getppages(npages, FIXED);
+
+  if (pa == 0) {
+    return 0;
+  }
+
+  return PADDR_TO_KVADDR(pa);
+}
+
+void
+free_kpages(vaddr_t addr) {
+  unsigned long long i, j;
+
+  //spinlock_acquire(&stealmem_lock);
+  lock_acquire(coremaplock);
+
+  for (i = 0; i < num_pages; i++) {
+    if (coremap[i].vaddr == addr) {
+      //for (j = 0; j < coremap[i].pagecount; j++) {
+        j = 0;
+        bzero((void *)coremap[i + j].vaddr, PAGE_SIZE);
+        coremap[i + j].state = FREE;
+        coremap[i + j].addrspace = NULL;
+        // update timestamp here.
+        coremap[i + j].pagecount = 0;
+      //}
+      break;
+    }
+  }
+
+  (void)addr;
+
+  //spinlock_release(&stealmem_lock);
+  lock_release(coremaplock);
+}
+
+// User pages interface to coremap.
+// Update the page table etc in the syscall.
+// The curthread there would take care of this.
+vaddr_t alloc_upages(int npages) {
+
+  vaddr_t va;
+
+  // We need to call a magic function here.
+
+  va = PADDR_TO_KVADDR(getppages(npages, DIRTY));
+
+  return va;
+
+}
+
+/*void page_free() {
+
+  if ()
+}*/
+
+void
+vm_tlbshootdown_all(void)
+{
+  panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+void
+vm_tlbshootdown(const struct tlbshootdown *ts)
+{
+  (void)ts;
+  panic("dumbvm tried to do tlb shootdown?!\n");
+}
+
+int
+vm_fault(int faulttype, vaddr_t faultaddress)
+{
+  vaddr_t vbase1, vtop1, vbase2, vtop2, stackbase, stacktop;
+  paddr_t paddr;
+  int i;
+  uint32_t ehi, elo;
+  struct addrspace *as;
+  int spl;
+
+  faultaddress &= PAGE_FRAME;
+
+  DEBUG(DB_VM, "dumbvm: fault: 0x%x\n", faultaddress);
+
+  switch (faulttype) {
+      case VM_FAULT_READONLY:
+    // We always create pages read-write, so we can't get this
+    panic("dumbvm: got VM_FAULT_READONLY\n");
+      case VM_FAULT_READ:
+      case VM_FAULT_WRITE:
+    break;
+      default:
+    return EINVAL;
+  }
+
+  as = curthread->t_addrspace;
+  if (as == NULL) {
+
+     // No address space set up. This is probably a kernel
+     // fault early in boot. Return EFAULT so as to panic
+     // instead of getting into an infinite faulting loop.
+    return EFAULT;
+  }
+
+  // Assert that the address space has been set up properly.
+  KASSERT(as->as_vbase1 != 0);
+  KASSERT(as->as_pbase1 != 0);
+  KASSERT(as->as_npages1 != 0);
+  //KASSERT(as->as_vbase2 != 0);
+  KASSERT(as->as_pbase2 != 0);
+  KASSERT(as->as_npages2 != 0);
+  KASSERT(as->as_stackpbase != 0);
+  KASSERT((as->as_vbase1 & PAGE_FRAME) == as->as_vbase1);
+  KASSERT((as->as_pbase1 & PAGE_FRAME) == as->as_pbase1);
+  KASSERT((as->as_vbase2 & PAGE_FRAME) == as->as_vbase2);
+  KASSERT((as->as_pbase2 & PAGE_FRAME) == as->as_pbase2);
+  KASSERT((as->as_stackpbase & PAGE_FRAME) == as->as_stackpbase);
+
+  vbase1 = as->as_vbase1;
+  vtop1 = vbase1 + as->as_npages1 * PAGE_SIZE;
+  vbase2 = as->as_vbase2;
+  vtop2 = vbase2 + as->as_npages2 * PAGE_SIZE;
+  stackbase = USERSTACK - DUMBVM_STACKPAGES * PAGE_SIZE;
+  stacktop = USERSTACK;
+
+  if (faultaddress >= vbase1 && faultaddress < vtop1) {
+    paddr = (faultaddress - vbase1) + as->as_pbase1;
+  }
+  else if (faultaddress >= vbase2 && faultaddress < vtop2) {
+    paddr = (faultaddress - vbase2) + as->as_pbase2;
+  }
+  else if (faultaddress >= stackbase && faultaddress < stacktop) {
+    paddr = (faultaddress - stackbase) + as->as_stackpbase;
+  }
+  else {
+    return EFAULT;
+  }
+
+  // make sure it's page-aligned
+  KASSERT((paddr & PAGE_FRAME) == paddr);
+
+  // Disable interrupts on this CPU while frobbing the TLB.
+  spl = splhigh();
+
+  for (i=0; i<NUM_TLB; i++) {
+    tlb_read(&ehi, &elo, i);
+    if (elo & TLBLO_VALID) {
+      continue;
+    }
+    ehi = faultaddress;
+    elo = paddr | TLBLO_DIRTY | TLBLO_VALID;
+    DEBUG(DB_VM, "dumbvm: 0x%x -> 0x%x\n", faultaddress, paddr);
+    tlb_write(ehi, elo, i);
+    splx(spl);
+    return 0;
+  }
+
+  kprintf("dumbvm: Ran out of TLB entries - cannot handle page fault\n");
+  splx(spl);
+  return EFAULT;
+}
+
+/*struct addrspace *
+as_create(void)
+{
+  struct addrspace *as = kmalloc(sizeof(struct addrspace));
+  if (as==NULL) {
+    return NULL;
+  }
+
+  as->as_vbase1 = 0;
+  as->as_pbase1 = 0;
+  as->as_npages1 = 0;
+  as->as_vbase2 = 0;
+  as->as_pbase2 = 0;
+  as->as_npages2 = 0;
+  as->as_stackpbase = 0;
+
+  return as;
+}
+
+void
+as_destroy(struct addrspace *as)
+{
+  kfree(as);
+}
+
+void
+as_activate(struct addrspace *as)
+{
+  int i, spl;
+
+  (void)as;
+
+  // Disable interrupts on this CPU while frobbing the TLB.
+  spl = splhigh();
+
+  for (i=0; i<NUM_TLB; i++) {
+    tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+  }
+
+  splx(spl);
+}
+
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+     int readable, int writeable, int executable)
+{
+  size_t npages;
+
+  // Align the region. First, the base... 
+  sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+  vaddr &= PAGE_FRAME;
+
+  // ...and now the length.
+  sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+  npages = sz / PAGE_SIZE;
+
+  // We don't use these - all pages are read-write
+  (void)readable;
+  (void)writeable;
+  (void)executable;
+
+  if (as->as_vbase1 == 0) {
+    as->as_vbase1 = vaddr;
+    as->as_npages1 = npages;
+    return 0;
+  }
+
+  if (as->as_vbase2 == 0) {
+    as->as_vbase2 = vaddr;
+    as->as_npages2 = npages;
+    return 0;
+  }
+
+  // Support for more than two regions is not available.
+  kprintf("dumbvm: Warning: too many regions\n");
+  return EUNIMP;
+}
+
+static
+void
+as_zero_region(paddr_t paddr, unsigned npages)
+{
+  bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+}
+
+int
+as_prepare_load(struct addrspace *as)
+{
+  KASSERT(as->as_pbase1 == 0);
+  KASSERT(as->as_pbase2 == 0);
+  KASSERT(as->as_stackpbase == 0);
+
+  as->as_pbase1 = getppages(as->as_npages1);
+  if (as->as_pbase1 == 0) {
+    return ENOMEM;
+  }
+
+  as->as_pbase2 = getppages(as->as_npages2);
+  if (as->as_pbase2 == 0) {
+    return ENOMEM;
+  }
+
+  as->as_stackpbase = getppages(DUMBVM_STACKPAGES);
+  if (as->as_stackpbase == 0) {
+    return ENOMEM;
+  }
+
+  as_zero_region(as->as_pbase1, as->as_npages1);
+  as_zero_region(as->as_pbase2, as->as_npages2);
+  as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+
+  return 0;
+}
+
+int
+as_complete_load(struct addrspace *as)
+{
+  (void)as;
+  return 0;
+}
+
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+  KASSERT(as->as_stackpbase != 0);
+
+  *stackptr = USERSTACK;
+  return 0;
+}
+
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+  struct addrspace *new;
+
+  new = as_create();
+  if (new==NULL) {
+    return ENOMEM;
+  }
+
+  new->as_vbase1 = old->as_vbase1;
+  new->as_npages1 = old->as_npages1;
+  new->as_vbase2 = old->as_vbase2;
+  new->as_npages2 = old->as_npages2;
+
+  // (Mis)use as_prepare_load to allocate some physical memory.
+  if (as_prepare_load(new)) {
+    as_destroy(new);
+    return ENOMEM;
+  }
+
+  KASSERT(new->as_pbase1 != 0);
+  KASSERT(new->as_pbase2 != 0);
+  KASSERT(new->as_stackpbase != 0);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+    (const void *)PADDR_TO_KVADDR(old->as_pbase1),
+    old->as_npages1*PAGE_SIZE);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+    (const void *)PADDR_TO_KVADDR(old->as_pbase2),
+    old->as_npages2*PAGE_SIZE);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+    (const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+    DUMBVM_STACKPAGES*PAGE_SIZE);
+
+  *ret = new;
+  return 0;
+}*/
diff --git a/kern/conf/conf.kern b/kern/conf/conf.kern
index d527f61..cef5fbd 100644
--- a/kern/conf/conf.kern
+++ b/kern/conf/conf.kern
@@ -333,6 +333,7 @@ file      vm/kmalloc.c
 
 optofffile dumbvm   vm/addrspace.c
 
+file arch/mips/vm/theomegavm.c
 #
 # Network
 # (nothing here yet)
@@ -367,6 +368,8 @@ file      vfs/devnull.c
 file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
+file      syscall/file.c
+file      syscall/proc.c
 
 #
 # Startup and initialization
diff --git a/kern/include/addrspace.h b/kern/include/addrspace.h
index 6788e97..c4ff646 100644
--- a/kern/include/addrspace.h
+++ b/kern/include/addrspace.h
@@ -1,31 +1,6 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
+ /* You can haz MIT GPL license.
+  *
+  */
 
 #ifndef _ADDRSPACE_H_
 #define _ADDRSPACE_H_
@@ -41,7 +16,7 @@
 struct vnode;
 
 
-/* 
+/*
  * Address space - data structure associated with the virtual memory
  * space of a process.
  *
@@ -59,6 +34,15 @@ struct addrspace {
         paddr_t as_stackpbase;
 #else
         /* Put stuff here for your VM system */
+        vaddr_t as_vbase1;
+        paddr_t as_pbase1;
+        size_t as_npages1;
+        vaddr_t as_vbase2;
+        paddr_t as_pbase2;
+        size_t as_npages2;
+        paddr_t as_stackpbase;
+
+        vaddr_t pagetablehead;
 #endif
 };
 
@@ -96,19 +80,19 @@ struct addrspace {
  *                back the initial stack pointer for the new process.
  */
 
+paddr_t getppages(unsigned long npages, int state);
+
+void as_zero_region(paddr_t paddr, unsigned npages);
+
 struct addrspace *as_create(void);
-int               as_copy(struct addrspace *src, struct addrspace **ret);
-void              as_activate(struct addrspace *);
-void              as_destroy(struct addrspace *);
-
-int               as_define_region(struct addrspace *as, 
-                                   vaddr_t vaddr, size_t sz,
-                                   int readable, 
-                                   int writeable,
-                                   int executable);
-int               as_prepare_load(struct addrspace *as);
-int               as_complete_load(struct addrspace *as);
-int               as_define_stack(struct addrspace *as, vaddr_t *initstackptr);
+int as_copy(struct addrspace *src, struct addrspace **ret);
+void as_activate(struct addrspace *);
+void as_destroy(struct addrspace *);
+
+int as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz, int readable, int writeable, int executable);
+int as_prepare_load(struct addrspace *as);
+int as_complete_load(struct addrspace *as);
+int as_define_stack(struct addrspace *as, vaddr_t *initstackptr);
 
 
 /*
diff --git a/kern/include/file.h b/kern/include/file.h
new file mode 100644
index 0000000..b3bef0c
--- /dev/null
+++ b/kern/include/file.h
@@ -0,0 +1,30 @@
+/*
+ * file.h contains the declarations that are needed
+ * for the File system calls (defined in kern/syscalls/file.c)
+ */
+
+#ifndef _FILE_H_
+#define _FILE_H_
+
+#include <types.h>
+
+struct File {
+  char *name;
+  int flags;
+  off_t offset;
+  int ref_count;
+  // We only care about the particular entry.
+  struct lock *lock;
+  struct vnode* vn;
+};
+
+int sys_open(const char *filename, int flags, int mode, int32_t *retval);
+int sys_close(int fd);
+int sys_read(int fd, void *buf, size_t buflen, int32_t *retval);
+int sys_write(int fd, const void *buf, size_t nbytes, int32_t *retval);
+int sys_dup2(int oldfd, int newfd);
+int sys_chdir(const char *pathname);
+int sys__getcwd(char *buf, size_t buflen);
+off_t sys_lseek(int fd, off_t pos, int whence, off_t *retval);
+
+#endif
diff --git a/kern/include/kern/errmsg.h b/kern/include/kern/errmsg.h
index 26e1e53..9102541 100644
--- a/kern/include/kern/errmsg.h
+++ b/kern/include/kern/errmsg.h
@@ -104,6 +104,7 @@ const char *const sys_errlist[] = {
 	"Connection reset by peer",   /* ECONNRESET */
 	"Message too large",          /* EMSGSIZE */
 	"Threads operation not supported",/* ENOTSUP */
+  "File descriptor already closed/does not exist" /* ENOFD */
 };
 
 /*
diff --git a/kern/include/kern/errno.h b/kern/include/kern/errno.h
index 6e5a91a..bb991e1 100644
--- a/kern/include/kern/errno.h
+++ b/kern/include/kern/errno.h
@@ -93,7 +93,7 @@
 #define ESOCKTNOSUPPORT 49     /* Socket type not supported */
 #define EPROTONOSUPPORT 50     /* Protocol not supported */
 #define EPROTOTYPE      51     /* Protocol wrong type for socket */
-#define EAFNOSUPPORT   52 /* Address family not supported by protocol family */
+#define EAFNOSUPPORT    52     /* Address family not supported by protocol family */
 #define ENOPROTOOPT     53     /* Protocol option not available */
 #define EADDRINUSE      54     /* Address already in use */
 #define EADDRNOTAVAIL   55     /* Cannot assign requested address */
@@ -107,5 +107,7 @@
 #define EMSGSIZE        63     /* Message too large */
 #define ENOTSUP         64     /* Threads operation not supported */
 
+// New errnos
+#define ENOFD           65     /* Access valid file descriptor not in use. */
 
 #endif /* _KERN_ERRNO_H_ */
diff --git a/kern/include/kern/file.h b/kern/include/kern/file.h
new file mode 100644
index 0000000..b3bef0c
--- /dev/null
+++ b/kern/include/kern/file.h
@@ -0,0 +1,30 @@
+/*
+ * file.h contains the declarations that are needed
+ * for the File system calls (defined in kern/syscalls/file.c)
+ */
+
+#ifndef _FILE_H_
+#define _FILE_H_
+
+#include <types.h>
+
+struct File {
+  char *name;
+  int flags;
+  off_t offset;
+  int ref_count;
+  // We only care about the particular entry.
+  struct lock *lock;
+  struct vnode* vn;
+};
+
+int sys_open(const char *filename, int flags, int mode, int32_t *retval);
+int sys_close(int fd);
+int sys_read(int fd, void *buf, size_t buflen, int32_t *retval);
+int sys_write(int fd, const void *buf, size_t nbytes, int32_t *retval);
+int sys_dup2(int oldfd, int newfd);
+int sys_chdir(const char *pathname);
+int sys__getcwd(char *buf, size_t buflen);
+off_t sys_lseek(int fd, off_t pos, int whence, off_t *retval);
+
+#endif
diff --git a/kern/include/kern/proc.h b/kern/include/kern/proc.h
new file mode 100644
index 0000000..c90a151
--- /dev/null
+++ b/kern/include/kern/proc.h
@@ -0,0 +1,36 @@
+// Global thread struct to store.
+
+#include <limits.h>
+#include <types.h>
+#include <mips/trapframe.h>
+#include <synch.h>
+
+#ifndef _PROC_H
+#define _PROC_H
+
+// Previously on It Does Not Work,
+//extern struct thread * pid_array[PID_MAX];
+
+struct Proc {
+
+  pid_t ppid;
+  pid_t pid;
+  struct semaphore *exit;
+  bool exited;
+  int exitcode;
+};
+
+
+void child_fork_entry(void *data1, unsigned long data2);
+
+struct thread * get_thread_by_pid(pid_t pid);
+pid_t get_next_pid(struct thread *new_thread);
+void free_this_pid(pid_t pid);
+
+pid_t sys_getpid(void);
+int sys_fork(struct trapframe *tf, pid_t *retval);
+//int sys_waitpid(pit_t pid, int *status, int options, int *retval); Wow. This was fucking frustrating.
+int sys_waitpid(pid_t pid, int *status, int options, int *retval);
+void sys__exit(int exitcode);
+
+#endif
diff --git a/kern/include/kern/types.h b/kern/include/kern/types.h
index 002d3b7..19ce1de 100644
--- a/kern/include/kern/types.h
+++ b/kern/include/kern/types.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
diff --git a/kern/include/proc.h b/kern/include/proc.h
new file mode 100644
index 0000000..6193096
--- /dev/null
+++ b/kern/include/proc.h
@@ -0,0 +1,38 @@
+// Global thread struct to store.
+
+#include <limits.h>
+#include <types.h>
+#include <mips/trapframe.h>
+#include <synch.h>
+
+#ifndef _PROC_H
+#define _PROC_H
+
+// Previously on It Does Not Work,
+//extern struct Proc * process_table[PID_MAX];
+
+struct Proc {
+
+  pid_t ppid;
+  pid_t pid;
+  struct semaphore *exit;
+  bool exited;
+  int exitcode;
+  struct thread *self;
+};
+
+void child_fork_entry(void *data1, unsigned long data2);
+
+int assign_pid(struct thread *new_thread);
+void free_this_pid(pid_t pid);
+struct Proc * get_process_by_pid(pid_t pid);
+struct thread * get_thread_by_pid(pid_t pid);
+
+pid_t sys_getpid(void);
+int sys_fork(struct trapframe *tf, pid_t *retval);
+//int sys_waitpid(pit_t pid, int *status, int options, int *retval); Wow. This was fucking frustrating.
+int sys_waitpid(pid_t pid, int *status, int options, int *retval);
+void sys__exit(int exitcode);
+int sys_execv(const char *program, char **args);
+
+#endif
diff --git a/kern/include/synch.h b/kern/include/synch.h
index ac3714b..64ebeb9 100644
--- a/kern/include/synch.h
+++ b/kern/include/synch.h
@@ -72,10 +72,16 @@ void V(struct semaphore *);
  * The name field is for easier debugging. A copy of the name is
  * (should be) made internally.
  */
+
+ // Stuff was added here for ASST1.
 struct lock {
-        char *lk_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+
+  // (don't forget to mark things volatile as needed)
+  char *lk_name;
+  struct wchan *lk_wchan;
+  struct spinlock lk_spinlock;
+  volatile struct thread *lk_curthread;
+  volatile int lk_hold;
 };
 
 struct lock *lock_create(const char *name);
@@ -111,10 +117,14 @@ void lock_destroy(struct lock *);
  * (should be) made internally.
  */
 
+// Stuff was added here for ASST1
 struct cv {
-        char *cv_name;
-        // add what you need here
-        // (don't forget to mark things volatile as needed)
+
+  // add what you need here
+
+  char              *cv_name;
+  struct wchan      *cv_wchan;
+  struct spinlock    cv_spinlock;
 };
 
 struct cv *cv_create(const char *name);
@@ -142,7 +152,14 @@ void cv_broadcast(struct cv *cv, struct lock *lock);
  */
 
 struct rwlock {
-        char *rwlock_name;
+
+  char              *rwl_name;
+  struct spinlock    rwl_spinlock;
+  struct wchan      *rwl_rwchan;
+  struct wchan      *rwl_wwchan;
+  int                mode;
+  struct semaphore  *rwl_rsem;
+  struct semaphone  *rwl_wsem;
 };
 
 struct rwlock * rwlock_create(const char *);
diff --git a/kern/include/syscall.h b/kern/include/syscall.h
index befd3d8..d2bc62a 100644
--- a/kern/include/syscall.h
+++ b/kern/include/syscall.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -30,6 +30,8 @@
 #ifndef _SYSCALL_H_
 #define _SYSCALL_H_
 
+#include <file.h>
+#include <proc.h>
 
 struct trapframe; /* from <machine/trapframe.h> */
 
@@ -48,7 +50,7 @@ void enter_forked_process(struct trapframe *tf);
 
 /* Enter user mode. Does not return. */
 void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
-		       vaddr_t entrypoint);
+                        vaddr_t entrypoint);
 
 
 /*
@@ -58,4 +60,22 @@ void enter_new_process(int argc, userptr_t argv, vaddr_t stackptr,
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
 
+// File System Calls
+/*int sys_open(const char *filename, int flags, int mode, int32_t *retval);
+int sys_close(int fd);
+int sys_read(int fd, void *buf, size_t buflen, int32_t *retval);
+int sys_write(int fd, const void *buf, size_t nbytes, int32_t *retval);
+int sys_dup2(int oldfd, int newfd);
+int sys_chdir(const char *pathname);
+int sys__getcwd(char *buf, size_t buflen);
+off_t sys_lseek(int fd, off_t pos, int whence, off_t *retval);
+
+// Process System Calls
+pid_t sys_getpid(void);
+int sys_fork(struct trapframe *tf, pid_t *retval);
+int sys_waitpid(pid_t pid, int *status, int options, int *retval);
+void sys__exit(int exitcode);*/
+
+
+
 #endif /* _SYSCALL_H_ */
diff --git a/kern/include/test.h b/kern/include/test.h
index 240d583..935e547 100644
--- a/kern/include/test.h
+++ b/kern/include/test.h
@@ -73,6 +73,10 @@ void turnright(void *, unsigned long);
 void stoplight_init(void);
 void stoplight_cleanup(void);
 
+// Helper Function
+struct semaphore * toSem(long);
+
+
 /*
  * Test code.
  */
@@ -105,7 +109,7 @@ int mallocstress(int, char **);
 int nettest(int, char **);
 
 /* Routine for running a user-level program. */
-int runprogram(char *progname);
+int runprogram(char *progname, char **args);
 
 /* Kernel menu system. */
 void menu(char *argstr);
diff --git a/kern/include/thread.h b/kern/include/thread.h
index 86706ca..221a387 100644
--- a/kern/include/thread.h
+++ b/kern/include/thread.h
@@ -38,6 +38,9 @@
 
 #include <spinlock.h>
 #include <threadlist.h>
+#include <limits.h>
+
+#include <file.h>
 
 struct addrspace;
 struct cpu;
@@ -112,6 +115,14 @@ struct thread {
 	struct vnode *t_cwd;		/* current working directory */
 
 	/* add more here as needed */
+
+  // File descriptor table.
+  struct File *file_desctable[OPEN_MAX];
+
+  // PIDs
+  pid_t ppid;
+
+  pid_t pid;
 };
 
 /* Call once during system startup to allocate data structures. */
diff --git a/kern/include/vm.h b/kern/include/vm.h
index e4e73d0..8877f2f 100644
--- a/kern/include/vm.h
+++ b/kern/include/vm.h
@@ -1,31 +1,7 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
+/* You can haz MIT GPL lisence.
  *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
  */
+#include <addrspace.h>
 
 #ifndef _VM_H_
 #define _VM_H_
@@ -36,7 +12,6 @@
  * You'll probably want to add stuff here.
  */
 
-
 #include <machine/vm.h>
 
 /* Fault-type arguments to vm_fault() */
@@ -44,6 +19,26 @@
 #define VM_FAULT_WRITE       1    /* A write was attempted */
 #define VM_FAULT_READONLY    2    /* A write to a readonly page was attempted*/
 
+typedef enum {FREE, DIRTY, CLEAN, FIXED} pagestate_t;
+
+// Under dumbvm, and we are for a while,
+// always have 48k of user stack.
+#define DUMBVM_STACKPAGES    12
+
+struct Page {
+
+  struct addrspace *addrspace;
+
+  vaddr_t vaddr;
+  paddr_t paddr;
+
+  // Much cleaner.
+  pagestate_t state;
+
+  time_t timestamp;
+
+  unsigned long long pagecount;
+};
 
 /* Initialization function */
 void vm_bootstrap(void);
@@ -55,6 +50,10 @@ int vm_fault(int faulttype, vaddr_t faultaddress);
 vaddr_t alloc_kpages(int npages);
 void free_kpages(vaddr_t addr);
 
+// Stuff for user functions.
+vaddr_t alloc_upages(int npages);
+void free_upages(vaddr_t addr);
+
 /* TLB shootdown handling called from interprocessor_interrupt */
 void vm_tlbshootdown_all(void);
 void vm_tlbshootdown(const struct tlbshootdown *);
diff --git a/kern/startup/main.c b/kern/startup/main.c
index be4c4b8..fa12650 100644
--- a/kern/startup/main.c
+++ b/kern/startup/main.c
@@ -1,3 +1,5 @@
+// vtangira@buffalo.edu
+
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
  *	The President and Fellows of Harvard College.
diff --git a/kern/startup/menu.c b/kern/startup/menu.c
index 6c71551..fbd12f0 100644
--- a/kern/startup/menu.c
+++ b/kern/startup/menu.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -55,15 +55,15 @@
 // XXX this should not be in this file
 void
 getinterval(time_t s1, uint32_t ns1, time_t s2, uint32_t ns2,
-	    time_t *rs, uint32_t *rns)
+      time_t *rs, uint32_t *rns)
 {
-	if (ns2 < ns1) {
-		ns2 += 1000000000;
-		s2--;
-	}
+  if (ns2 < ns1) {
+    ns2 += 1000000000;
+    s2--;
+  }
 
-	*rns = ns2 - ns1;
-	*rs = s2 - s1;
+  *rns = ns2 - ns1;
+  *rs = s2 - s1;
 }
 
 ////////////////////////////////////////////////////////////
@@ -85,29 +85,39 @@ static
 void
 cmd_progthread(void *ptr, unsigned long nargs)
 {
-	char **args = ptr;
-	char progname[128];
-	int result;
+  char **args = ptr;
+  char progname[128];
+  int result;
 
-	KASSERT(nargs >= 1);
+  KASSERT(nargs >= 1);
 
-	if (nargs > 2) {
-		kprintf("Warning: argument passing from menu not supported\n");
-	}
+  /* Hope we fit. */
+  KASSERT(strlen(args[0]) < sizeof(progname));
 
-	/* Hope we fit. */
-	KASSERT(strlen(args[0]) < sizeof(progname));
+  strcpy(progname, args[0]);
 
-	strcpy(progname, args[0]);
+  if (nargs == 1) {
+    args[1] = NULL;
+  }
 
-	result = runprogram(progname);
-	if (result) {
-		kprintf("Running program %s failed: %s\n", args[0],
-			strerror(result));
-		return;
-	}
+  // NULL the last pointer.
+  args[nargs] = NULL;
 
-	/* NOTREACHED: runprogram only returns on error. */
+  /*if (nargs > 2) {
+    //kprintf("Warning: argument passing from menu not supported\n");
+  }*/
+
+  result = runprogram(progname, args);
+
+  if (result) {
+    kprintf("Running program %s failed: %s\n", args[0],
+      strerror(result));
+    return;
+  }
+
+  sys__exit(0);
+
+  /* NOTREACHED: runprogram only returns on error. */
 }
 
 /*
@@ -126,23 +136,25 @@ static
 int
 common_prog(int nargs, char **args)
 {
-	int result;
+  int result, status, retval;
+  struct thread *prog;
 
 #if OPT_SYNCHPROBS
-	kprintf("Warning: this probably won't work with a "
-		"synchronization-problems kernel.\n");
-#endif
+  kprintf("Warning: this probably won't work with a "
+    "synchronization-problems kernel.\n");
+#endif 
+
+  result = thread_fork(args[0] , cmd_progthread, args, nargs, &prog);
+
+  if (result) {
+    kprintf("thread_fork failed: %s\n", strerror(result));
+    return result;
+  }
 
-	result = thread_fork(args[0] /* thread name */,
-			cmd_progthread /* thread function */,
-			args /* thread arg */, nargs /* thread arg */,
-			NULL);
-	if (result) {
-		kprintf("thread_fork failed: %s\n", strerror(result));
-		return result;
-	}
+  if(sys_waitpid(prog->pid, &status, 0, &retval))
+    kprintf("MENU waitpid failed\n");
 
-	return 0;
+  return 0;
 }
 
 /*
@@ -152,16 +164,16 @@ static
 int
 cmd_prog(int nargs, char **args)
 {
-	if (nargs < 2) {
-		kprintf("Usage: p program [arguments]\n");
-		return EINVAL;
-	}
+  if (nargs < 2) {
+    kprintf("Usage: p program [arguments]\n");
+    return EINVAL;
+  }
 
-	/* drop the leading "p" */
-	args++;
-	nargs--;
+  /* drop the leading "p" */
+  args++;
+  nargs--;
 
-	return common_prog(nargs, args);
+  return common_prog(nargs, args);
 }
 
 /*
@@ -171,15 +183,15 @@ static
 int
 cmd_shell(int nargs, char **args)
 {
-	(void)args;
-	if (nargs != 1) {
-		kprintf("Usage: s\n");
-		return EINVAL;
-	}
+  (void)args;
+  if (nargs != 1) {
+    kprintf("Usage: s\n");
+    return EINVAL;
+  }
 
-	args[0] = (char *)_PATH_SHELL;
+  args[0] = (char *)_PATH_SHELL;
 
-	return common_prog(nargs, args);
+  return common_prog(nargs, args);
 }
 
 /*
@@ -189,12 +201,12 @@ static
 int
 cmd_chdir(int nargs, char **args)
 {
-	if (nargs != 2) {
-		kprintf("Usage: cd directory\n");
-		return EINVAL;
-	}
+  if (nargs != 2) {
+    kprintf("Usage: cd directory\n");
+    return EINVAL;
+  }
 
-	return vfs_chdir(args[1]);
+  return vfs_chdir(args[1]);
 }
 
 /*
@@ -204,28 +216,28 @@ static
 int
 cmd_pwd(int nargs, char **args)
 {
-	char buf[PATH_MAX+1];
-	int result;
-	struct iovec iov;
-	struct uio ku;
+  char buf[PATH_MAX+1];
+  int result;
+  struct iovec iov;
+  struct uio ku;
 
-	(void)nargs;
-	(void)args;
+  (void)nargs;
+  (void)args;
 
-	uio_kinit(&iov, &ku, buf, sizeof(buf)-1, 0, UIO_READ);
-	result = vfs_getcwd(&ku);
-	if (result) {
-		kprintf("vfs_getcwd failed (%s)\n", strerror(result));
-		return result;
-	}
+  uio_kinit(&iov, &ku, buf, sizeof(buf)-1, 0, UIO_READ);
+  result = vfs_getcwd(&ku);
+  if (result) {
+    kprintf("vfs_getcwd failed (%s)\n", strerror(result));
+    return result;
+  }
 
-	/* null terminate */
-	buf[sizeof(buf)-1-ku.uio_resid] = 0;
+  /* null terminate */
+  buf[sizeof(buf)-1-ku.uio_resid] = 0;
 
-	/* print it */
-	kprintf("%s\n", buf);
+  /* print it */
+  kprintf("%s\n", buf);
 
-	return 0;
+  return 0;
 }
 
 /*
@@ -235,12 +247,12 @@ static
 int
 cmd_sync(int nargs, char **args)
 {
-	(void)nargs;
-	(void)args;
+  (void)nargs;
+  (void)args;
 
-	vfs_sync();
+  vfs_sync();
 
-	return 0;
+  return 0;
 }
 
 /*
@@ -250,11 +262,11 @@ static
 int
 cmd_panic(int nargs, char **args)
 {
-	(void)nargs;
-	(void)args;
+  (void)nargs;
+  (void)args;
 
-	panic("User requested panic\n");
-	return 0;
+  panic("User requested panic\n");
+  return 0;
 }
 
 /*
@@ -264,13 +276,13 @@ static
 int
 cmd_quit(int nargs, char **args)
 {
-	(void)nargs;
-	(void)args;
+  (void)nargs;
+  (void)args;
 
-	vfs_sync();
-	sys_reboot(RB_POWEROFF);
-	thread_exit();
-	return 0;
+  vfs_sync();
+  sys_reboot(RB_POWEROFF);
+  thread_exit();
+  return 0;
 }
 
 /*
@@ -279,64 +291,64 @@ cmd_quit(int nargs, char **args)
 
 /* Table of mountable filesystem types. */
 static const struct {
-	const char *name;
-	int (*func)(const char *device);
+  const char *name;
+  int (*func)(const char *device);
 } mounttable[] = {
 #if OPT_SFS
-	{ "sfs", sfs_mount },
+  { "sfs", sfs_mount },
 #endif
-	{ NULL, NULL }
+  { NULL, NULL }
 };
 
 static
 int
 cmd_mount(int nargs, char **args)
 {
-	char *fstype;
-	char *device;
-	int i;
-
-	if (nargs != 3) {
-		kprintf("Usage: mount fstype device:\n");
-		return EINVAL;
-	}
-
-	fstype = args[1];
-	device = args[2];
-
-	/* Allow (but do not require) colon after device name */
-	if (device[strlen(device)-1]==':') {
-		device[strlen(device)-1] = 0;
-	}
-
-	for (i=0; mounttable[i].name; i++) {
-		if (!strcmp(mounttable[i].name, fstype)) {
-			return mounttable[i].func(device);
-		}
-	}
-	kprintf("Unknown filesystem type %s\n", fstype);
-	return EINVAL;
+  char *fstype;
+  char *device;
+  int i;
+
+  if (nargs != 3) {
+    kprintf("Usage: mount fstype device:\n");
+    return EINVAL;
+  }
+
+  fstype = args[1];
+  device = args[2];
+
+  /* Allow (but do not require) colon after device name */
+  if (device[strlen(device)-1]==':') {
+    device[strlen(device)-1] = 0;
+  }
+
+  for (i=0; mounttable[i].name; i++) {
+    if (!strcmp(mounttable[i].name, fstype)) {
+      return mounttable[i].func(device);
+    }
+  }
+  kprintf("Unknown filesystem type %s\n", fstype);
+  return EINVAL;
 }
 
 static
 int
 cmd_unmount(int nargs, char **args)
 {
-	char *device;
+  char *device;
 
-	if (nargs != 2) {
-		kprintf("Usage: unmount device:\n");
-		return EINVAL;
-	}
+  if (nargs != 2) {
+    kprintf("Usage: unmount device:\n");
+    return EINVAL;
+  }
 
-	device = args[1];
+  device = args[1];
 
-	/* Allow (but do not require) colon after device name */
-	if (device[strlen(device)-1]==':') {
-		device[strlen(device)-1] = 0;
-	}
+  /* Allow (but do not require) colon after device name */
+  if (device[strlen(device)-1]==':') {
+    device[strlen(device)-1] = 0;
+  }
 
-	return vfs_unmount(device);
+  return vfs_unmount(device);
 }
 
 /*
@@ -351,33 +363,33 @@ static
 int
 cmd_bootfs(int nargs, char **args)
 {
-	char *device;
+  char *device;
 
-	if (nargs != 2) {
-		kprintf("Usage: bootfs device\n");
-		return EINVAL;
-	}
+  if (nargs != 2) {
+    kprintf("Usage: bootfs device\n");
+    return EINVAL;
+  }
 
-	device = args[1];
+  device = args[1];
 
-	/* Allow (but do not require) colon after device name */
-	if (device[strlen(device)-1]==':') {
-		device[strlen(device)-1] = 0;
-	}
+  /* Allow (but do not require) colon after device name */
+  if (device[strlen(device)-1]==':') {
+    device[strlen(device)-1] = 0;
+  }
 
-	return vfs_setbootfs(device);
+  return vfs_setbootfs(device);
 }
 
 static
 int
 cmd_kheapstats(int nargs, char **args)
 {
-	(void)nargs;
-	(void)args;
+  (void)nargs;
+  (void)args;
 
-	kheap_printstats();
-	
-	return 0;
+  kheap_printstats();
+  
+  return 0;
 }
 
 ////////////////////////////////////////
@@ -388,112 +400,112 @@ static
 void
 showmenu(const char *name, const char *x[])
 {
-	int ct, half, i;
-
-	kprintf("\n");
-	kprintf("%s\n", name);
-	
-	for (i=ct=0; x[i]; i++) {
-		ct++;
-	}
-	half = (ct+1)/2;
-
-	for (i=0; i<half; i++) {
-		kprintf("    %-36s", x[i]);
-		if (i+half < ct) {
-			kprintf("%s", x[i+half]);
-		}
-		kprintf("\n");
-	}
-
-	kprintf("\n");
+  int ct, half, i;
+
+  kprintf("\n");
+  kprintf("%s\n", name);
+
+  for (i=ct=0; x[i]; i++) {
+    ct++;
+  }
+  half = (ct+1)/2;
+
+  for (i=0; i<half; i++) {
+    kprintf("    %-36s", x[i]);
+    if (i+half < ct) {
+      kprintf("%s", x[i+half]);
+    }
+    kprintf("\n");
+  }
+
+  kprintf("\n");
 }
 
 static const char *opsmenu[] = {
-	"[s]       Shell                     ",
-	"[p]       Other program             ",
-	"[mount]   Mount a filesystem        ",
-	"[unmount] Unmount a filesystem      ",
-	"[bootfs]  Set \"boot\" filesystem     ",
-	"[pf]      Print a file              ",
-	"[cd]      Change directory          ",
-	"[pwd]     Print current directory   ",
-	"[sync]    Sync filesystems          ",
-	"[panic]   Intentional panic         ",
-	"[q]       Quit and shut down        ",
-	NULL
+  "[s]       Shell                     ",
+  "[p]       Other program             ",
+  "[mount]   Mount a filesystem        ",
+  "[unmount] Unmount a filesystem      ",
+  "[bootfs]  Set \"boot\" filesystem     ",
+  "[pf]      Print a file              ",
+  "[cd]      Change directory          ",
+  "[pwd]     Print current directory   ",
+  "[sync]    Sync filesystems          ",
+  "[panic]   Intentional panic         ",
+  "[q]       Quit and shut down        ",
+  NULL
 };
 
 static
 int
 cmd_opsmenu(int n, char **a)
 {
-	(void)n;
-	(void)a;
+  (void)n;
+  (void)a;
 
-	showmenu("OS/161 operations menu", opsmenu);
-	return 0;
+  showmenu("OS/161 operations menu", opsmenu);
+  return 0;
 }
 
 static const char *testmenu[] = {
-	"[at]  Array test                    ",
-	"[bt]  Bitmap test                   ",
-	"[km1] Kernel malloc test            ",
-	"[km2] kmalloc stress test           ",
-	"[tt1] Thread test 1                 ",
-	"[tt2] Thread test 2                 ",
-	"[tt3] Thread test 3                 ",
+  "[at]  Array test                    ",
+  "[bt]  Bitmap test                   ",
+  "[km1] Kernel malloc test            ",
+  "[km2] kmalloc stress test           ",
+  "[tt1] Thread test 1                 ",
+  "[tt2] Thread test 2                 ",
+  "[tt3] Thread test 3                 ",
 #if OPT_NET
-	"[net] Network test                  ",
+  "[net] Network test                  ",
 #endif
-	"[sy1] Semaphore test                ",
-	"[sy2] Lock test             (1)     ",
-	"[sy3] CV test               (1)     ",
-	"[sy5] CV test 2             (1)     ",
-	"[sp1] Whalematching Driver  (1)     ",
-	"[sp2] Stoplight Driver      (1)     ",
-	"[fs1] Filesystem test               ",
-	"[fs2] FS read stress        (4)     ",
-	"[fs3] FS write stress       (4)     ",
-	"[fs4] FS write stress 2     (4)     ",
-	"[fs5] FS create stress      (4)     ",
-	NULL
+  "[sy1] Semaphore test                ",
+  "[sy2] Lock test             (1)     ",
+  "[sy3] CV test               (1)     ",
+  "[sy5] CV test 2             (1)     ",
+  "[sp1] Whalematching Driver  (1)     ",
+  "[sp2] Stoplight Driver      (1)     ",
+  "[fs1] Filesystem test               ",
+  "[fs2] FS read stress        (4)     ",
+  "[fs3] FS write stress       (4)     ",
+  "[fs4] FS write stress 2     (4)     ",
+  "[fs5] FS create stress      (4)     ",
+  NULL
 };
 
 static
 int
 cmd_testmenu(int n, char **a)
 {
-	(void)n;
-	(void)a;
+  (void)n;
+  (void)a;
 
-	showmenu("OS/161 tests menu", testmenu);
-	kprintf("    (1) These tests will fail until you finish the "
-		"synch assignment.\n");
-	kprintf("    (4) These tests may fail until you finish the "
-		"file system assignment.\n");
-	kprintf("\n");
+  showmenu("OS/161 tests menu", testmenu);
+  kprintf("    (1) These tests will fail until you finish the "
+    "synch assignment.\n");
+  kprintf("    (4) These tests may fail until you finish the "
+    "file system assignment.\n");
+  kprintf("\n");
 
-	return 0;
+  return 0;
 }
 
 static const char *mainmenu[] = {
-	"[?o] Operations menu                ",
-	"[?t] Tests menu                     ",
-	"[kh] Kernel heap stats              ",
-	"[q] Quit and shut down              ",
-	NULL
+  "[?o] Operations menu                ",
+  "[?t] Tests menu                     ",
+  "[kh] Kernel heap stats              ",
+  "[q] Quit and shut down              ",
+  NULL
 };
 
 static
 int
 cmd_mainmenu(int n, char **a)
 {
-	(void)n;
-	(void)a;
+  (void)n;
+  (void)a;
 
-	showmenu("OS/161 kernel menu", mainmenu);
-	return 0;
+  showmenu("OS/161 kernel menu", mainmenu);
+  return 0;
 }
 
 ////////////////////////////////////////
@@ -501,67 +513,67 @@ cmd_mainmenu(int n, char **a)
 // Command table.
 
 static struct {
-	const char *name;
-	int (*func)(int nargs, char **args);
+  const char *name;
+  int (*func)(int nargs, char **args);
 } cmdtable[] = {
-	/* menus */
-	{ "?",		cmd_mainmenu },
-	{ "h",		cmd_mainmenu },
-	{ "help",	cmd_mainmenu },
-	{ "?o",		cmd_opsmenu },
-	{ "?t",		cmd_testmenu },
-
-	/* operations */
-	{ "s",		cmd_shell },
-	{ "p",		cmd_prog },
-	{ "mount",	cmd_mount },
-	{ "unmount",	cmd_unmount },
-	{ "bootfs",	cmd_bootfs },
-	{ "pf",		printfile },
-	{ "cd",		cmd_chdir },
-	{ "pwd",	cmd_pwd },
-	{ "sync",	cmd_sync },
-	{ "panic",	cmd_panic },
-	{ "q",		cmd_quit },
-	{ "exit",	cmd_quit },
-	{ "halt",	cmd_quit },
-
-
-	/* stats */
-	{ "kh",         cmd_kheapstats },
-
-	/* base system tests */
-	{ "at",		arraytest },
-	{ "bt",		bitmaptest },
-	{ "km1",	malloctest },
-	{ "km2",	mallocstress },
+  /* menus */
+  { "?",    cmd_mainmenu },
+  { "h",    cmd_mainmenu },
+  { "help", cmd_mainmenu },
+  { "?o",   cmd_opsmenu },
+  { "?t",   cmd_testmenu },
+
+  /* operations */
+  { "s",    cmd_shell },
+  { "p",    cmd_prog },
+  { "mount",  cmd_mount },
+  { "unmount",  cmd_unmount },
+  { "bootfs", cmd_bootfs },
+  { "pf",   printfile },
+  { "cd",   cmd_chdir },
+  { "pwd",  cmd_pwd },
+  { "sync", cmd_sync },
+  { "panic",  cmd_panic },
+  { "q",    cmd_quit },
+  { "exit", cmd_quit },
+  { "halt", cmd_quit },
+
+
+  /* stats */
+  { "kh",         cmd_kheapstats },
+
+  /* base system tests */
+  { "at",   arraytest },
+  { "bt",   bitmaptest },
+  { "km1",  malloctest },
+  { "km2",  mallocstress },
 #if OPT_NET
-	{ "net",	nettest },
+  { "net",  nettest },
 #endif
-	{ "tt1",	threadtest },
-	{ "tt2",	threadtest2 },
-	{ "tt3",	threadtest3 },
-	{ "sy1",	semtest },
-
-	/* synchronization assignment tests */
-	{ "sy2",	locktest },
-	{ "sy3",	cvtest },
-	{ "sy5",	cvtest2 },
-	
+  { "tt1",  threadtest },
+  { "tt2",  threadtest2 },
+  { "tt3",  threadtest3 },
+  { "sy1",  semtest },
+
+  /* synchronization assignment tests */
+  { "sy2",  locktest },
+  { "sy3",  cvtest },
+  { "sy5",  cvtest2 },
+
 #if OPT_SYNCHPROBS
   /* synchronization problem tests */
   { "sp1", whalemating },
   { "sp2", stoplight },
 #endif
 
-	/* file system assignment tests */
-	{ "fs1",	fstest },
-	{ "fs2",	readstress },
-	{ "fs3",	writestress },
-	{ "fs4",	writestress2 },
-	{ "fs5",	createstress },
+  /* file system assignment tests */
+  { "fs1",  fstest },
+  { "fs2",  readstress },
+  { "fs3",  writestress },
+  { "fs4",  writestress2 },
+  { "fs5",  createstress },
 
-	{ NULL, NULL }
+  { NULL, NULL }
 };
 
 /*
@@ -571,52 +583,52 @@ static
 int
 cmd_dispatch(char *cmd)
 {
-	time_t beforesecs, aftersecs, secs;
-	uint32_t beforensecs, afternsecs, nsecs;
-	char *args[MAXMENUARGS];
-	int nargs=0;
-	char *word;
-	char *context;
-	int i, result;
-
-	for (word = strtok_r(cmd, " \t", &context);
-	     word != NULL;
-	     word = strtok_r(NULL, " \t", &context)) {
-
-		if (nargs >= MAXMENUARGS) {
-			kprintf("Command line has too many words\n");
-			return E2BIG;
-		}
-		args[nargs++] = word;
-	}
-
-	if (nargs==0) {
-		return 0;
-	}
-
-	for (i=0; cmdtable[i].name; i++) {
-		if (*cmdtable[i].name && !strcmp(args[0], cmdtable[i].name)) {
-			KASSERT(cmdtable[i].func!=NULL);
-
-			gettime(&beforesecs, &beforensecs);
-
-			result = cmdtable[i].func(nargs, args);
-
-			gettime(&aftersecs, &afternsecs);
-			getinterval(beforesecs, beforensecs,
-				    aftersecs, afternsecs,
-				    &secs, &nsecs);
-
-			kprintf("Operation took %lu.%09lu seconds\n",
-				(unsigned long) secs,
-				(unsigned long) nsecs);
-
-			return result;
-		}
-	}
-
-	kprintf("%s: Command not found\n", args[0]);
-	return EINVAL;
+  time_t beforesecs, aftersecs, secs;
+  uint32_t beforensecs, afternsecs, nsecs;
+  char *args[MAXMENUARGS];
+  int nargs=0;
+  char *word;
+  char *context;
+  int i, result;
+
+  for (word = strtok_r(cmd, " \t", &context);
+       word != NULL;
+       word = strtok_r(NULL, " \t", &context)) {
+
+    if (nargs >= MAXMENUARGS) {
+      kprintf("Command line has too many words\n");
+      return E2BIG;
+    }
+    args[nargs++] = word;
+  }
+
+  if (nargs==0) {
+    return 0;
+  }
+
+  for (i=0; cmdtable[i].name; i++) {
+    if (*cmdtable[i].name && !strcmp(args[0], cmdtable[i].name)) {
+      KASSERT(cmdtable[i].func!=NULL);
+
+      gettime(&beforesecs, &beforensecs);
+
+      result = cmdtable[i].func(nargs, args);
+
+      gettime(&aftersecs, &afternsecs);
+      getinterval(beforesecs, beforensecs,
+            aftersecs, afternsecs,
+            &secs, &nsecs);
+
+      kprintf("Operation took %lu.%09lu seconds\n",
+        (unsigned long) secs,
+        (unsigned long) nsecs);
+
+      return result;
+    }
+  }
+
+  kprintf("%s: Command not found\n", args[0]);
+  return EINVAL;
 }
 
 /*
@@ -630,26 +642,26 @@ static
 void
 menu_execute(char *line, int isargs)
 {
-	char *command;
-	char *context;
-	int result;
-
-	for (command = strtok_r(line, ";", &context);
-	     command != NULL;
-	     command = strtok_r(NULL, ";", &context)) {
-
-		if (isargs) {
-			kprintf("OS/161 kernel: %s\n", command);
-		}
-
-		result = cmd_dispatch(command);
-		if (result) {
-			kprintf("Menu command failed: %s\n", strerror(result));
-			if (isargs) {
-				panic("Failure processing kernel arguments\n");
-			}
-		}
-	}
+  char *command;
+  char *context;
+  int result;
+
+  for (command = strtok_r(line, ";", &context);
+       command != NULL;
+       command = strtok_r(NULL, ";", &context)) {
+
+    if (isargs) {
+      kprintf("OS/161 kernel: %s\n", command);
+    }
+
+    result = cmd_dispatch(command);
+    if (result) {
+      kprintf("Menu command failed: %s\n", strerror(result));
+      if (isargs) {
+        panic("Failure processing kernel arguments\n");
+      }
+    }
+  }
 }
 
 /*
@@ -672,13 +684,13 @@ menu_execute(char *line, int isargs)
 void
 menu(char *args)
 {
-	char buf[64];
+  char buf[64];
 
-	menu_execute(args, 1);
+  menu_execute(args, 1);
 
-	while (1) {
-		kprintf("OS/161 kernel [? for menu]: ");
-		kgets(buf, sizeof(buf));
-		menu_execute(buf, 0);
-	}
+  while (1) {
+    kprintf("OS/161 kernel [? for menu]: ");
+    kgets(buf, sizeof(buf));
+    menu_execute(buf, 0);
+  }
 }
diff --git a/kern/synchprobs/problems.c b/kern/synchprobs/problems.c
index 81d2f0e..d69fa1f 100644
--- a/kern/synchprobs/problems.c
+++ b/kern/synchprobs/problems.c
@@ -47,7 +47,18 @@
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+// Male start, female start. Male end, Female end.
+// Much better than the quantum hanky-panky I had to present with the 
+// bacteria.
+struct semaphore *ms, *fs, *me, *fe;
+
 void whalemating_init() {
+
+  ms = sem_create("Male Start", 0);
+  fs = sem_create("Female Start", 0);
+  me = sem_create("Male End", 0);
+  fe = sem_create("Female End", 0);
+
   return;
 }
 
@@ -55,6 +66,12 @@ void whalemating_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void whalemating_cleanup() {
+
+  sem_destroy(ms);
+  sem_destroy(fs);
+  sem_destroy(me);
+  sem_destroy(fe);
+
   return;
 }
 
@@ -65,7 +82,11 @@ male(void *p, unsigned long which)
   (void)which;
   
   male_start();
-	// Implement this function 
+
+	// Implement this function
+  V(ms);
+  P(me);
+
   male_end();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -81,7 +102,11 @@ female(void *p, unsigned long which)
   (void)which;
   
   female_start();
+
 	// Implement this function 
+  V(fs);
+  P(fe);
+
   female_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -97,7 +122,13 @@ matchmaker(void *p, unsigned long which)
   (void)which;
   
   matchmaker_start();
+
 	// Implement this function 
+  P(ms);
+  P(fs);
+  V(me);
+  V(fe);
+
   matchmaker_end();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
@@ -137,7 +168,21 @@ matchmaker(void *p, unsigned long which)
 // functions will allow you to do local initialization. They are called at
 // the top of the corresponding driver code.
 
+// Cars should drive on the left, unless you're a lefty and the config
+// makes sense. :P
+
+struct semaphore *zero, *one, *two, *three;
+struct lock *flow_lock;
+
 void stoplight_init() {
+
+  zero = sem_create("Zero", 1);
+  one = sem_create("One", 1);
+  two = sem_create("Two", 1);
+  three = sem_create("Three", 1);
+
+  flow_lock = lock_create("Stoplight Flow Lock");
+
   return;
 }
 
@@ -145,14 +190,80 @@ void stoplight_init() {
 // care if your problems leak memory, but if you do, use this to clean up.
 
 void stoplight_cleanup() {
+
+  sem_destroy(zero);
+  sem_destroy(one);
+  sem_destroy(two);
+  sem_destroy(three);
+
+  lock_destroy(flow_lock);
+
   return;
 }
 
+struct semaphore * toSem(long num) {
+
+  switch(num) {
+    case 0:
+      return zero;
+    case 1:
+      return one;
+    case 2:
+      return two;
+    case 3:
+      return three;
+  }
+
+  // End of non-viod function
+  return zero;
+}
+
 void
 gostraight(void *p, unsigned long direction)
 {
+
+  long opr, prev; 
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+
+  // Direction Change: X, X + 3, X + 2
+
+  opr = 0;
+
+  if (!opr) {
+    // X
+    lock_acquire(flow_lock);
+    opr++;
+    P(toSem(direction));
+    inQuadrant(direction);
+    prev = direction;
+    direction = (direction + 3) % 4;
+  //  lock_release(flow_lock);
+  }
+
+  while (opr < 3) {
+//    lock_acquire(flow_lock);
+    opr++;
+    P(toSem(direction)); 
+    inQuadrant(direction);
+    V(toSem(prev));
+    prev = direction;
+
+    if (opr == 2) {
+      // X + 3
+      direction = (direction + 3) % 4;
+    }
+     
+    if (opr == 3) {
+      // X + 2
+      direction = (direction + 2) % 4;
+    }
+
+    //lock_release(flow_lock);
+  }
+
+  lock_release(flow_lock);
+
+  leaveIntersection();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -164,7 +275,46 @@ void
 turnleft(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+  
+  long opr, prev;
+
+  // Direction Change: X, X + 3, X + 2, X + 1
+
+  opr = 0;
+
+  if (!opr) {
+    lock_acquire(flow_lock);
+    opr++;
+    P(toSem(direction));
+    inQuadrant(direction);
+    prev = direction;
+    direction = (direction + 3) % 4;
+//    lock_release(flow_lock);
+  }
+
+  while (opr < 4) {
+    // Put a lock here.
+  //  lock_acquire(flow_lock);
+    opr++;
+    P(toSem(direction));
+    inQuadrant(direction);
+    V(toSem(prev));
+    prev = direction;
+
+    if (opr == 2) {
+      direction = (direction + 2) % 4;
+    }
+
+    if (opr == 3) {
+      direction = (direction + 1) % 4;
+    }
+
+  //  lock_release(flow_lock);
+  }
+
+  lock_release(flow_lock);
+
+  leaveIntersection();
   
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
@@ -176,7 +326,23 @@ void
 turnright(void *p, unsigned long direction)
 {
 	struct semaphore * stoplightMenuSemaphore = (struct semaphore *)p;
-  (void)direction;
+
+  long prev;
+
+  lock_acquire(flow_lock);
+  P(toSem(direction));
+  inQuadrant(direction);
+  prev = direction;
+  direction = (direction + 3) % 4;
+//  lock_release(flow_lock);
+  
+//  lock_acquire(flow_lock);
+  P(toSem(direction));
+  inQuadrant(direction);
+  V(toSem(prev));
+  lock_release(flow_lock);
+  
+  leaveIntersection();
 
   // 08 Feb 2012 : GWA : Please do not change this code. This is so that your
   // stoplight driver can return to the menu cleanly.
diff --git a/kern/syscall/file.c b/kern/syscall/file.c
new file mode 100644
index 0000000..5deb126
--- /dev/null
+++ b/kern/syscall/file.c
@@ -0,0 +1,430 @@
+// Including all these files to prevent stupid build errors.
+// (Copied from thread.h). kern/fcntl.h hahaha #sorry
+#include <kern/types.h>
+#include <limits.h>
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <array.h>
+#include <cpu.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <wchan.h>
+#include <thread.h>
+#include <threadlist.h>
+#include <threadprivate.h>
+#include <current.h>
+#include <synch.h>
+#include <addrspace.h>
+#include <mainbus.h>
+#include <vnode.h>
+#include <vfs.h>
+#include <copyinout.h>
+#include <kern/fcntl.h>
+#include <../../user/include/errno.h>
+#include <uio.h>
+// hahaha
+//#include <kern/include/kern/stat.h>
+#include <kern/stat.h>
+#include <kern/seek.h>
+
+#include <file.h>
+
+/*
+ * File sys_calls are defined here.
+ */
+
+/* Assign a file descriptor. 0, 1, 2 are not defined right now.
+ * These are defined when they are used to avoid complications
+ * when doing a fork() (even for init).
+ */
+// retval is going to be the fd. The return value is going to be error code.
+int sys_open(const char *filename, int flags, int mode, int32_t *retval) {
+
+  char *k_filename, *k_con;
+  int fd, result, temp;
+  int errno;
+  size_t length;
+  // struct stat file_stat - not needed for this assignment on append.
+
+  // Check if it works without this.
+  fd = -1;
+
+  // Check valid name.
+  if (filename == "" || strlen(filename) > NAME_MAX) {
+    errno = EFAULT;
+    return -1;
+  }
+
+  // Check valid flags. AND with 0_ACCMODE to extract them.
+  temp = flags & O_ACCMODE;
+  if (!(temp == O_RDONLY || temp == O_WRONLY || temp == O_RDWR)) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  // Filename is in userland.
+  if (filename != "con:") {
+    k_filename = (char *)kmalloc(sizeof(char) * strlen(filename));
+    if (k_filename == NULL) {
+      errno = ENOMEM;
+      return -1;
+    }
+    copyinstr((const_userptr_t)filename, k_filename, PATH_MAX, &length);
+  }
+
+  if (filename == "con:" && temp == O_RDONLY)
+    fd = 0;
+  else if (filename == "con:" && temp == O_WRONLY && mode == 0664)
+    fd = 1;
+  else if (filename == "con:" && temp == O_WRONLY && mode == 0665) {
+    fd = 2;
+    mode = 0664;
+  }
+  else {
+    get_new_name:fd = 3;
+    while (curthread->file_desctable[fd] != NULL && fd < OPEN_MAX)
+      fd++;
+  }
+
+  // Death by file table.
+  if (fd == OPEN_MAX) {
+    errno = EMFILE;
+    kfree(k_filename);
+    return -1;
+  }
+
+  // Check that the file was not allocated.
+  if (curthread->file_desctable[fd] == NULL) {
+    curthread->file_desctable[fd] = kmalloc(sizeof(struct File));
+    if (filename == "con:") {
+      k_con = kmalloc(strlen("con:") * sizeof(char));
+      strcpy(k_con, "con:");
+      curthread->file_desctable[fd]->name = k_con;
+    }
+    else
+      curthread->file_desctable[fd]->name = k_filename;
+  }
+  else { // What you have done here is correct, not for the console.
+    // Check that the threads match and have a goto otherwise.
+    // If the names are the same, they probably are the same
+    // user thread. Hopefully there aren't cooler race conditions.
+    if (filename != "con:") {
+      if (curthread->file_desctable[fd]->name != k_filename)
+        goto get_new_name;
+    }
+  }
+
+  // VOP_OPEN(node->vn, flags)
+  if((result = vfs_open(curthread->file_desctable[fd]->name, flags, mode, &curthread->file_desctable[fd]->vn))) {
+    errno = EIO;
+    kfree(k_filename);
+    kfree(k_con);
+    kfree(curthread->file_desctable[fd]);
+    curthread->file_desctable[fd] = NULL;
+    kprintf ("Something went wrong opening the file %d, result %d", fd, result);
+    return -1;
+  }
+
+  // Do the file stuff.
+  curthread->file_desctable[fd]->ref_count = 1;
+  curthread->file_desctable[fd]->offset = 0;
+  curthread->file_desctable[fd]->flags = flags;
+  curthread->file_desctable[fd]->lock = lock_create("File Lock");
+
+  *retval = fd;
+
+  return 0;
+}
+
+int sys_close(int fd) {
+
+  struct File *temp_file;
+  int errno;
+
+  if (fd < 0 && fd > OPEN_MAX) {
+    errno = EBADF;
+    return -1;
+  }
+
+  // File already closed.
+  if (curthread->file_desctable[fd] == NULL) {
+    errno = ENOFD;
+    return -1;
+  }
+
+  if(curthread->file_desctable[fd]->ref_count == 1) {
+    VOP_CLOSE(curthread->file_desctable[fd]->vn);
+    temp_file = curthread->file_desctable[fd];
+    curthread->file_desctable[fd] = NULL;
+    lock_destroy(temp_file->lock);
+    kfree(temp_file);
+  }
+  else {
+    curthread->file_desctable[fd]->ref_count--;
+  }
+
+  return 0;
+}
+
+int sys_read(int fd, void *buf, size_t buflen, int32_t *retval) {
+
+  struct uio *read_uio;
+  struct iovec *read_iovec;
+  char *k_buf;
+  int errno;
+
+  if (fd < 0 || fd > OPEN_MAX) {
+    errno = EBADF;
+    return -1;
+  }
+
+  // Read from the console. Open everytime.
+  if (fd == 0)
+    sys_open("con:", O_RDONLY, 0664, &fd);
+
+  // Check if the normal file was opened before
+  if (curthread->file_desctable[fd] == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+
+  // Check for valid flags
+  if (curthread->file_desctable[fd]->flags == O_WRONLY) {
+    errno = EBADF;
+    return -1;
+  }
+
+  lock_acquire(curthread->file_desctable[fd]->lock);
+
+  read_uio = (struct uio *)kmalloc(sizeof(struct uio));
+  read_iovec = (struct iovec *)kmalloc(sizeof(struct iovec));
+
+  k_buf = (char *)kmalloc(buflen * sizeof(char));
+
+  uio_kinit(read_iovec, read_uio, (void *)k_buf, buflen, curthread->file_desctable[fd]->offset, UIO_READ);
+
+  if(VOP_READ(curthread->file_desctable[fd]->vn, read_uio))
+    return -1;
+
+  *retval = buflen - read_uio->uio_resid;
+
+  //curthread->file_desctable[fd]->offset += *retval;
+  curthread->file_desctable[fd]->offset = read_uio->uio_offset;
+
+  // This is not needed.
+  /*if(VOP_STAT(curthread->file_desctable[fd]->vn, &file_stat))
+    return -1;
+  if (curthread->file_desctable[fd]->offset == file_stat.st_size)
+    *retval = 0;*/
+
+  lock_release(curthread->file_desctable[fd]->lock);
+
+  if (fd == 0)
+    sys_close(fd);
+
+  if(copyout((const void *)k_buf, (void *)buf, buflen))
+    return -1;
+
+  kfree(k_buf);
+  kfree(read_uio);
+  kfree(read_iovec);
+
+  return 0;
+}
+
+int sys_write(int fd, const void *buf, size_t nbytes, int32_t *retval) {
+
+  struct uio *write_uio;
+  struct iovec *write_iovec;
+  char *k_buf;
+  int errno;
+
+  if (fd < 0 || fd > OPEN_MAX) {
+    errno = EBADF;
+    return -1;
+  }
+
+  if (fd == 1) {
+    sys_open("con:", O_WRONLY, 0664, &fd);
+  }
+  else if (fd == 2) {
+    sys_open("con:", O_WRONLY, 0665, &fd);
+  }
+
+  if (curthread->file_desctable[fd] == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+
+  if (curthread->file_desctable[fd]->flags == O_RDONLY) {
+    errno = EBADF;
+    return -1;
+  }
+
+  lock_acquire(curthread->file_desctable[fd]->lock);
+
+  k_buf = (char *)kmalloc(nbytes * sizeof(char));
+
+  //copyinstr((const_userptr_t)buf, k_buf, nbytes, &length); Does not work.
+  copyin((const_userptr_t)buf, k_buf, nbytes);
+
+  write_uio = (struct uio *)kmalloc(sizeof(struct uio));
+
+  write_iovec = (struct iovec *)kmalloc(sizeof(struct iovec));
+
+  // offset was zero before.
+  uio_kinit(write_iovec, write_uio, (void *)k_buf, nbytes, curthread->file_desctable[fd]->offset, UIO_WRITE);
+
+  if(VOP_WRITE(curthread->file_desctable[fd]->vn, write_uio))
+    return -1;
+
+  *retval = nbytes - write_uio->uio_resid;
+
+  curthread->file_desctable[fd]->offset = write_uio->uio_offset;
+
+  lock_release(curthread->file_desctable[fd]->lock);
+
+  if (fd == 1 || fd == 2)
+    sys_close(fd);
+
+  kfree(k_buf);
+  kfree(write_uio);
+  kfree(write_iovec);
+
+  return 0;
+}
+
+int sys_dup2(int oldfd, int newfd) {
+
+  int errno;
+
+  if (oldfd < 0 || newfd < 0) {
+    errno = EBADF;
+    return -1;
+  }
+
+  //lock_acquire(&curthread->file_desctable[oldfd]->lock);
+
+  if (oldfd == newfd)
+    return 0;
+
+  // Check that the newfd is null else close it.
+  if (curthread->file_desctable[newfd] != NULL) {
+    sys_close(newfd);
+    curthread->file_desctable[newfd] = NULL;
+  }
+
+  curthread->file_desctable[newfd] = curthread->file_desctable[oldfd];
+  curthread->file_desctable[newfd]->ref_count++;
+
+  //lock_release(&curthread->file_desctable[oldfd]->lock);
+
+  return 0;
+}
+
+int sys_chdir(const char *pathname) {
+
+  char *k_pathname;
+  int result;
+  size_t size;
+
+  result = 0;
+
+  size = sizeof(pathname);
+
+  k_pathname = (char *)kmalloc(size * sizeof(char));
+
+  copyinstr((const_userptr_t)pathname, k_pathname, size, &size);
+
+  if ((result = vfs_chdir(k_pathname))) {
+    kfree(k_pathname);
+    return -1;
+  }
+
+  kfree(k_pathname);
+
+  return 0;
+}
+
+int sys__getcwd(char *buf, size_t buflen) {
+
+  char *k_buf;
+  int errno;
+  struct uio *getcwd_uio;
+  struct iovec *getcwd_iovec;
+
+  if (buf == NULL) {
+    errno = EFAULT;
+    return -1;
+  }
+
+  k_buf = (char *)kmalloc(buflen * sizeof(char));
+
+  getcwd_iovec = (struct iovec *)kmalloc(sizeof(struct iovec));
+
+  getcwd_uio = (struct uio *)kmalloc(sizeof(struct uio));
+
+  uio_kinit(getcwd_iovec, getcwd_uio, k_buf, buflen, 0, UIO_READ);
+
+  if(vfs_getcwd(getcwd_uio))
+    return -1;
+
+  copyout((const void*)k_buf, (void *)buf, sizeof(buflen));
+
+  return 0;
+}
+
+// I'm late, I'm late, I'm late!
+off_t sys_lseek(int fd, off_t pos, int whence, off_t *retval) {
+
+  int errno;
+  off_t new_offset;
+  struct stat file_stat;
+
+  if (fd < 0 || fd > OPEN_MAX) {
+    errno = EBADF;
+    return -1;
+  }
+
+  if (curthread->file_desctable[fd] == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+
+  //lock_acquire(&curthread->file_desctable[fd]->lock);
+
+  if(VOP_STAT(curthread->file_desctable[fd]->vn, &file_stat))
+    return -1;
+
+  if (whence == SEEK_SET)
+    new_offset = pos;
+  else if (whence == SEEK_CUR) {
+    new_offset = curthread->file_desctable[fd]->offset + pos;
+  }
+  else if (whence == SEEK_END) {
+    new_offset = file_stat.st_size + pos;
+  }
+  else {
+    errno = EINVAL;
+    return -1;
+  }
+
+  if (new_offset < 0) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  if (VOP_TRYSEEK(curthread->file_desctable[fd]->vn, new_offset)) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  curthread->file_desctable[fd]->offset = new_offset;
+
+  *retval = new_offset;
+
+  //lock_release(&curthread->file_desctable[fd]->lock);
+
+  return 0;
+}
diff --git a/kern/syscall/proc.c b/kern/syscall/proc.c
new file mode 100644
index 0000000..ab7f58c
--- /dev/null
+++ b/kern/syscall/proc.c
@@ -0,0 +1,367 @@
+#include <proc.h>
+
+#include <kern/types.h>
+#include <limits.h>
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <array.h>
+#include <cpu.h>
+#include <spl.h>
+#include <spinlock.h>
+#include <wchan.h>
+#include <thread.h>
+#include <threadlist.h>
+#include <threadprivate.h>
+#include <current.h>
+#include <synch.h>
+#include <addrspace.h>
+#include <mainbus.h>
+#include <vnode.h>
+#include <vfs.h>
+#include <copyinout.h>
+#include <kern/fcntl.h>
+#include <../../user/include/errno.h>
+#include <uio.h>
+#include <synch.h>
+#include <kern/wait.h>
+#include <syscall.h>
+
+#define ARGSIZE 20
+
+// System processes.
+static struct Proc * process_table[PID_MAX];
+
+// Zombie table. Double tap to be sure. Bad idea.
+//static struct thread * zombie_table[PID_MAX];
+
+int assign_pid(struct thread *new_thread) {
+
+  pid_t pid;
+  int errno;
+  struct Proc *entry;
+
+  //a = splhigh();
+
+  pid = PID_MIN;
+  while (process_table[pid] != NULL)
+    pid++;
+
+  if (pid == PID_MAX) {
+    errno = ENPROC;
+    //splx(a);
+    return -1;
+  }
+
+  entry = (struct Proc *)kmalloc(sizeof(struct Proc));
+
+  new_thread->pid = pid;
+
+  entry->ppid = new_thread->ppid;
+  entry->pid = pid;
+  entry->exited = 0;
+  entry->exitcode = 0;
+  entry->exit = sem_create("Child Sem", 0);
+  entry->self = new_thread;
+
+  process_table[pid] = entry;
+
+  //splx(a);
+
+  return pid;
+}
+
+void free_this_pid(pid_t pid) {
+
+  struct Proc *proc;
+  int a;
+
+  a = splhigh();
+
+  proc = get_process_by_pid(pid);
+
+  if (proc != NULL) {
+    sem_destroy(proc->exit);
+    kfree(process_table[pid]);
+    process_table[pid] = NULL;
+  }
+
+  splx(a);
+}
+
+struct Proc * get_process_by_pid(pid_t pid) {
+    return process_table[pid];
+}
+
+struct thread * get_thread_by_pid(pid_t pid) {
+  return process_table[pid]->self;
+}
+
+void child_fork_entry(void *data1, unsigned long data2) {
+
+  struct addrspace* addrspace;
+  struct trapframe tf, *tf_ptr;
+
+  tf_ptr = (struct trapframe *)data1;
+
+  // Indicate success.
+  tf_ptr->tf_a3 = 0;
+  tf_ptr->tf_v0 = 0;
+
+  // goto next instruction after fork
+  tf_ptr->tf_epc += 4;
+
+  // Copy addrspace to stack and activate.
+  addrspace = ((struct addrspace *)data2);
+  curthread->t_addrspace = addrspace;
+  // as_copy(&addrspace, &curthread->t_addrspace);
+  as_activate(curthread->t_addrspace);
+
+  // Copy trapfram and enter usermode.
+  tf = *tf_ptr;
+  mips_usermode(&tf);
+}
+
+// Process Sys Calls.
+
+pid_t sys_getpid() {
+  return curthread->pid;
+}
+
+int sys_fork(struct trapframe *tf, pid_t *retval) {
+
+  struct addrspace *new_addrspace;
+  int result, errno, i, a;
+  struct trapframe *new_tf;
+  struct thread *child;
+
+  a = splhigh();
+
+  //new_addrspace = kmalloc(sizeof(struct addrspace));
+  if((result = as_copy(curthread->t_addrspace, &new_addrspace))) {
+    errno = ENOMEM;
+    return result;
+  }
+
+  new_tf = kmalloc(sizeof(struct trapframe));
+  *new_tf = *tf;
+
+  // figure out how to get the name.
+  if((result = thread_fork("child", child_fork_entry, (struct trapframe *)new_tf, (unsigned long)new_addrspace, &child)))
+    return result;
+
+  i = 3;
+  // Increase the reference count.
+  while (curthread->file_desctable[i] != NULL) {
+    curthread->file_desctable[i]->ref_count += 1;
+    child->file_desctable[i] = curthread->file_desctable[i];
+  }
+
+  child->ppid = curthread->pid;
+
+  assign_pid(child);
+
+  *retval = child->pid;
+
+  splx(a);
+
+  return 0;
+}
+
+int sys_waitpid(pid_t pid, int *status, int options, int *retval) {
+
+  int errno;
+  struct Proc *childp;
+
+  if (options != 0) {
+    errno = EINVAL;
+    return -1;
+  }
+
+  // Waiting for yourself.
+  if (pid == curthread->pid) {
+    errno = ECHILD;
+    return -1;
+  }
+
+  childp = get_process_by_pid(pid);
+  if (childp == NULL) {
+    errno = ESRCH;
+    return -1;
+  }
+
+  // Check that we are not waiting on a parent
+  if (childp->pid == curthread->ppid) {
+    errno = ECHILD;
+    return -1;
+  }
+
+  // Check that the parent is waiting on the child
+  if (childp->ppid != curthread->pid) {
+    errno = ECHILD;
+    return -1;
+  }
+
+  if (childp->exited == 0) {
+      P(childp->exit);
+  }
+
+  //*status = childp->exitcode; Gaaaaah.
+  copyout(&childp->exitcode, (userptr_t)status, sizeof(int));
+
+  *retval = pid;
+
+  free_this_pid(pid);
+
+  return 0;
+}
+
+void sys__exit(int exitcode) {
+
+  struct Proc *childp, *parentp;
+  int a;
+
+  a = splhigh();
+
+  if (curthread->ppid >= 2) {
+
+    parentp = get_process_by_pid(curthread->ppid);
+
+    if (parentp->exited != 1) {
+
+      childp = get_process_by_pid(curthread->pid);
+
+      childp->exitcode = _MKWVAL(exitcode);
+
+      childp->exited = 1;
+
+      V(childp->exit);
+    }
+    else {
+      free_this_pid(curthread->pid);
+    }
+  }
+
+  splx(a);
+
+  thread_exit();
+}
+
+//int execv(const char *program, char **args);
+int sys_execv(const char *program, char **args) {
+
+  // #define ARGSIZE 20
+
+  int argc, result, temp, i, errno;
+  size_t actual;
+  char *kargs, *ptr, *name, *userptrs[10];
+  struct vnode *vn;
+  vaddr_t entrypoint, userstk;
+
+  // There wan't a problem with this in file name copy
+  // and I therefore suspect there isn't one here.
+  // what happens to the case where the first argument is
+  // the program name?
+
+  // Check valid program.
+  if ((result = copyinstr((const_userptr_t)program, name, 100, &actual))) {
+    errno = ENOENT;
+    return result;
+  }
+  // Get the program into memory.
+  //name = kstrdup(program);
+  if ((result = vfs_open(name, O_RDONLY, 0, &vn))) {
+    return result;
+  }
+
+  // Prepare addrspace.
+  KASSERT(curthread->t_addrspace == NULL);
+  if((curthread->t_addrspace = as_create()) == NULL) {
+    vfs_close(vn);
+    errno = ENOMEM;
+    return -1;
+  }
+
+  as_activate(curthread->t_addrspace);
+
+  // Gandalf The White.
+  if((result = load_elf(vn, &entrypoint))) {
+    vfs_close(vn);
+    errno = ENOEXEC;
+    return -1;
+  }
+
+  vfs_close(vn);
+
+  // Setup user stack.
+  if ((result = as_define_stack(curthread->t_addrspace, &userstk))) {
+    return result;
+  }
+
+  // Get the ags in and pad them.
+  argc = 0;
+  while (1) {
+
+    ptr = (char *)kmalloc(sizeof(char));
+    // Use ptr
+    if((result = copyin((const_userptr_t)(args + argc), (void *)ptr, sizeof(char)))) {
+      errno = EFAULT;
+      return result;
+    }
+    if (ptr == NULL) {
+
+      userstk -= 4 * sizeof(char);
+
+      // Not needed. Just update the pointer.
+      /*if((result = copyout((const void *)args[argc], (userptr_t)userstk, sizeof(char)))) {
+        return result;
+      }*/
+      break;
+    }
+
+    kargs = (char *)kmalloc(sizeof(char) * ARGSIZE);
+
+    // Use ptr
+    if((result = copyinstr((const_userptr_t)args[argc], kargs, ARGSIZE, &actual))) {
+      errno = E2BIG;
+      return result;
+    }
+
+    // Pad.
+    temp = strlen(kargs) + 1;
+    temp += (4 - (temp % 4));
+    for (i = strlen(kargs) + 1; i < temp; i++)
+      kargs[i] = '\0';
+
+    // Move the stakptr;
+    userstk -= temp;
+
+    //copyout the arg to stack.
+    if((result = copyout((const void *)kargs , (userptr_t)userstk, temp))) {
+      return result;
+    }
+
+    userptrs[argc] = (char *)userstk;
+
+    //kprintf("kargv[%d]: %p - %s\n", argc, (void *)userstk, userptrs[argc]);
+
+    argc++;
+  }
+
+  // Pack the user pointers into the user stack.
+  for (i = argc - 1; i >= 0; i--) {
+
+    userstk -= sizeof(char *);
+
+    //if((result = copyout((const void *)userptrs[i] , (userptr_t)userstk, sizeof(char *)))) { :| :/
+    if((result = copyout((const void *)(userptrs + i) , (userptr_t)userstk, sizeof(char *)))) {
+      return result;
+    }
+  }
+
+  // What?! I'm Agent Smith?!
+  enter_new_process(argc, (userptr_t)userstk, userstk, entrypoint);
+
+  panic("enter_new_process returned. Fusion failed.\n");
+  return EINVAL;
+}
diff --git a/kern/syscall/runprogram.c b/kern/syscall/runprogram.c
index a6f45c8..a500b83 100644
--- a/kern/syscall/runprogram.c
+++ b/kern/syscall/runprogram.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -45,6 +45,10 @@
 #include <syscall.h>
 #include <test.h>
 
+#include <copyinout.h>
+
+#define ARGSIZE 20
+
 /*
  * Load program "progname" and start running it in usermode.
  * Does not return except on error.
@@ -52,55 +56,100 @@
  * Calls vfs_open on progname and thus may destroy it.
  */
 int
-runprogram(char *progname)
+runprogram(char *progname, char **args)
 {
-	struct vnode *v;
-	vaddr_t entrypoint, stackptr;
-	int result;
-
-	/* Open the file. */
-	result = vfs_open(progname, O_RDONLY, 0, &v);
-	if (result) {
-		return result;
-	}
-
-	/* We should be a new thread. */
-	KASSERT(curthread->t_addrspace == NULL);
-
-	/* Create a new address space. */
-	curthread->t_addrspace = as_create();
-	if (curthread->t_addrspace==NULL) {
-		vfs_close(v);
-		return ENOMEM;
-	}
-
-	/* Activate it. */
-	as_activate(curthread->t_addrspace);
-
-	/* Load the executable. */
-	result = load_elf(v, &entrypoint);
-	if (result) {
-		/* thread_exit destroys curthread->t_addrspace */
-		vfs_close(v);
-		return result;
-	}
-
-	/* Done with the file now. */
-	vfs_close(v);
-
-	/* Define the user stack in the address space */
-	result = as_define_stack(curthread->t_addrspace, &stackptr);
-	if (result) {
-		/* thread_exit destroys curthread->t_addrspace */
-		return result;
-	}
-
-	/* Warp to user mode. */
-	enter_new_process(0 /*argc*/, NULL /*userspace addr of argv*/,
-			  stackptr, entrypoint);
-	
-	/* enter_new_process does not return. */
-	panic("enter_new_process returned\n");
-	return EINVAL;
-}
+  struct vnode *v;
+  int argc, result, temp, i;
+  char *kargs, *name, *userptrs[10] , *ptr;
+  vaddr_t entrypoint, userstk;
+
+  /* Open the file. */
+  name = kstrdup(progname);
+  result = vfs_open(progname, O_RDONLY, 0, &v);
+  if (result) {
+    return result;
+  }
+
+  /* We should be a new thread. */
+  KASSERT(curthread->t_addrspace == NULL);
+
+  /* Create a new address space. */
+  curthread->t_addrspace = as_create();
+  if (curthread->t_addrspace==NULL) {
+    vfs_close(v);
+    return ENOMEM;
+  }
+
+  /* Activate it. */
+  as_activate(curthread->t_addrspace);
+
+  /* Load the executable. */
+  result = load_elf(v, &entrypoint);
+  if (result) {
+    /* thread_exit destroys curthread->t_addrspace */
+    vfs_close(v);
+    return result;
+  }
+
+  /* Done with the file now. */
+  vfs_close(v);
+
+  /* Define the user stack in the address space */
+  result = as_define_stack(curthread->t_addrspace, &userstk);
+  if (result) {
+    /* thread_exit destroys curthread->t_addrspace */
+    return result;
+  }
+
+
+  argc = 0;
+  while (1) {
+
+    ptr = (char *)kmalloc(sizeof(char));
 
+    if (args[argc] == NULL || args[argc] == "\b") {
+      userstk -= 4 * sizeof(char);
+      break;
+    }
+    ptr = kstrdup(args[argc]);
+
+    kargs = (char *)kmalloc(sizeof(char) * ARGSIZE);
+    kargs = kstrdup(ptr);
+
+    temp = strlen(kargs) + 1;
+    temp += (4 - (temp % 4));
+    for (i = strlen(kargs) + 1; i < temp; i++)
+      kargs[i] = '\0';
+
+    // Move the stakptr;
+    userstk -= temp;
+
+    //copyout the arg to stack.
+    if((result = copyout((const void *)kargs , (userptr_t)userstk, temp))) {
+      return result;
+    }
+
+    userptrs[argc] = (char *)userstk;
+
+    argc++;
+  }
+
+  // Pack the user pointers into the user stack.
+  for (i = argc - 1; i >= 0; i--) {
+
+    userstk -= sizeof(char *);
+
+    //if((result = copyout((const void *)userptrs[i] , (userptr_t)userstk, sizeof(char *)))) { :| :/
+    if((result = copyout((const void *)(userptrs + i) , (userptr_t)userstk, sizeof(char *)))) {
+      return result;
+    }
+  }
+
+
+  // What?! I'm Agent Smith?!
+  enter_new_process(argc, (userptr_t)userstk, userstk, entrypoint);
+
+  /* enter_new_process does not return. */
+  panic("enter_new_process returned\n");
+  return EINVAL;
+}
diff --git a/kern/thread/spinlock.c b/kern/thread/spinlock.c
index 06df2f0..b8999a8 100644
--- a/kern/thread/spinlock.c
+++ b/kern/thread/spinlock.c
@@ -116,11 +116,13 @@ spinlock_acquire(struct spinlock *lk)
 void
 spinlock_release(struct spinlock *lk)
 {
+
 	/* this must work before curcpu initialization */
 	if (CURCPU_EXISTS()) {
 		KASSERT(lk->lk_holder == curcpu->c_self);
 	}
 
+
 	lk->lk_holder = NULL;
 	spinlock_data_set(&lk->lk_lock, 0);
 	spllower(IPL_HIGH, IPL_NONE);
diff --git a/kern/thread/synch.c b/kern/thread/synch.c
index 9a7468c..28ce447 100644
--- a/kern/thread/synch.c
+++ b/kern/thread/synch.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -62,14 +62,14 @@ sem_create(const char *name, int initial_count)
                 return NULL;
         }
 
-	sem->sem_wchan = wchan_create(sem->sem_name);
-	if (sem->sem_wchan == NULL) {
-		kfree(sem->sem_name);
-		kfree(sem);
-		return NULL;
-	}
+  sem->sem_wchan = wchan_create(sem->sem_name);
+  if (sem->sem_wchan == NULL) {
+    kfree(sem->sem_name);
+    kfree(sem);
+    return NULL;
+  }
 
-	spinlock_init(&sem->sem_lock);
+  spinlock_init(&sem->sem_lock);
         sem->sem_count = initial_count;
 
         return sem;
@@ -80,9 +80,9 @@ sem_destroy(struct semaphore *sem)
 {
         KASSERT(sem != NULL);
 
-	/* wchan_cleanup will assert if anyone's waiting on it */
-	spinlock_cleanup(&sem->sem_lock);
-	wchan_destroy(sem->sem_wchan);
+  /* wchan_cleanup will assert if anyone's waiting on it */
+  spinlock_cleanup(&sem->sem_lock);
+  wchan_destroy(sem->sem_wchan);
         kfree(sem->sem_name);
         kfree(sem);
 }
@@ -100,33 +100,33 @@ P(struct semaphore *sem)
          */
         KASSERT(curthread->t_in_interrupt == false);
 
-	spinlock_acquire(&sem->sem_lock);
+  spinlock_acquire(&sem->sem_lock);
         while (sem->sem_count == 0) {
-		/*
-		 * Bridge to the wchan lock, so if someone else comes
-		 * along in V right this instant the wakeup can't go
-		 * through on the wchan until we've finished going to
-		 * sleep. Note that wchan_sleep unlocks the wchan.
-		 *
-		 * Note that we don't maintain strict FIFO ordering of
-		 * threads going through the semaphore; that is, we
-		 * might "get" it on the first try even if other
-		 * threads are waiting. Apparently according to some
-		 * textbooks semaphores must for some reason have
-		 * strict ordering. Too bad. :-)
-		 *
-		 * Exercise: how would you implement strict FIFO
-		 * ordering?
-		 */
-		wchan_lock(sem->sem_wchan);
-		spinlock_release(&sem->sem_lock);
+    /*
+     * Bridge to the wchan lock, so if someone else comes
+     * along in V right this instant the wakeup can't go
+     * through on the wchan until we've finished going to
+     * sleep. Note that wchan_sleep unlocks the wchan.
+     *
+     * Note that we don't maintain strict FIFO ordering of
+     * threads going through the semaphore; that is, we
+     * might "get" it on the first try even if other
+     * threads are waiting. Apparently according to some
+     * textbooks semaphores must for some reason have
+     * strict ordering. Too bad. :-)
+     *
+     * Exercise: how would you implement strict FIFO
+     * ordering?
+     */
+    wchan_lock(sem->sem_wchan);
+    spinlock_release(&sem->sem_lock);
                 wchan_sleep(sem->sem_wchan);
 
-		spinlock_acquire(&sem->sem_lock);
+    spinlock_acquire(&sem->sem_lock);
         }
         KASSERT(sem->sem_count > 0);
         sem->sem_count--;
-	spinlock_release(&sem->sem_lock);
+  spinlock_release(&sem->sem_lock);
 }
 
 void
@@ -134,13 +134,13 @@ V(struct semaphore *sem)
 {
         KASSERT(sem != NULL);
 
-	spinlock_acquire(&sem->sem_lock);
+  spinlock_acquire(&sem->sem_lock);
 
         sem->sem_count++;
         KASSERT(sem->sem_count > 0);
-	wchan_wakeone(sem->sem_wchan);
+  wchan_wakeone(sem->sem_wchan);
 
-	spinlock_release(&sem->sem_lock);
+  spinlock_release(&sem->sem_lock);
 }
 
 ////////////////////////////////////////////////////////////
@@ -162,9 +162,22 @@ lock_create(const char *name)
                 kfree(lock);
                 return NULL;
         }
-        
+
         // add stuff here as needed
-        
+
+        lock->lk_wchan = wchan_create("Lock wchan");
+        if (lock->lk_wchan == NULL) {
+          kfree (lock->lk_name);
+          kfree (lock);
+          return NULL;
+        }
+
+        spinlock_init(&lock->lk_spinlock);
+        lock->lk_curthread = NULL;
+        lock->lk_hold = 0;
+
+        //end
+
         return lock;
 }
 
@@ -174,7 +187,14 @@ lock_destroy(struct lock *lock)
         KASSERT(lock != NULL);
 
         // add stuff here as needed
-        
+
+        if (lock->lk_hold == 0) {
+          spinlock_cleanup(&lock->lk_spinlock);
+          wchan_destroy(lock->lk_wchan);
+        }
+        else
+          panic("Lock destory called when being held. Bad code, bad");
+        //end
         kfree(lock->lk_name);
         kfree(lock);
 }
@@ -184,7 +204,24 @@ lock_acquire(struct lock *lock)
 {
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+        spinlock_acquire(&lock->lk_spinlock);
+
+        while(lock->lk_hold == 1) {
+
+          wchan_lock(lock->lk_wchan);
+          spinlock_release(&lock->lk_spinlock);
+          wchan_sleep(lock->lk_wchan);
+          spinlock_acquire(&lock->lk_spinlock);
+        }
+
+        lock->lk_hold = 1;
+        lock->lk_curthread = curthread;
+
+        spinlock_release(&lock->lk_spinlock);
+
+        //end
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 void
@@ -192,17 +229,46 @@ lock_release(struct lock *lock)
 {
         // Write this
 
-        (void)lock;  // suppress warning until code gets written
+        KASSERT(lock != NULL);
+
+        //spinlock_acquire(&lock->lk_spinlock);
+
+        if (lock_do_i_hold(lock)) {
+
+          spinlock_acquire(&lock->lk_spinlock);
+          lock->lk_curthread = NULL;
+          lock->lk_hold = 0;
+          // Two days of struggle and me not
+          // reading the code right was the
+          // problem!!! wchan will not wake
+          // someone up randomly. This is there
+          // in the wchan include file.
+          wchan_wakeone(lock->lk_wchan);
+          spinlock_release(&lock->lk_spinlock);
+        }
+
+        //end
+
+        //(void)lock;  // suppress warning until code gets written
 }
 
 bool
 lock_do_i_hold(struct lock *lock)
 {
-        // Write this
+       // Write this
+
+       // KASSERT(curthread->t_in_interrupt == false);
+
+        if (curthread == lock->lk_curthread)
+          return true;
+        else
+          return false;
+
+        //end
 
-        (void)lock;  // suppress warning until code gets written
+        //(void)lock;  // suppress warning until code gets written
 
-        return true; // dummy until code gets written
+        //return true; // dummy until code gets written
 }
 
 ////////////////////////////////////////////////////////////
@@ -213,55 +279,215 @@ lock_do_i_hold(struct lock *lock)
 struct cv *
 cv_create(const char *name)
 {
-        struct cv *cv;
 
-        cv = kmalloc(sizeof(struct cv));
-        if (cv == NULL) {
-                return NULL;
-        }
+  struct cv *cv;
 
-        cv->cv_name = kstrdup(name);
-        if (cv->cv_name==NULL) {
-                kfree(cv);
-                return NULL;
-        }
-        
-        // add stuff here as needed
-        
-        return cv;
+  cv = kmalloc(sizeof(struct cv));
+  if (cv == NULL) {
+    return NULL;
+  }
+
+  cv->cv_name = kstrdup(name);
+  if (cv->cv_name==NULL) {
+    kfree(cv);
+    return NULL;
+  }
+
+  // add stuff here as needed
+
+  cv->cv_wchan = wchan_create("CV wchan");
+  if (cv->cv_wchan == NULL) {
+
+    kfree(cv->cv_name);
+    kfree(cv);
+    return NULL;
+  }
+
+  spinlock_init(&cv->cv_spinlock);
+
+  // end add stuff
+
+  return cv;
 }
 
 void
 cv_destroy(struct cv *cv)
 {
-        KASSERT(cv != NULL);
 
-        // add stuff here as needed
-        
-        kfree(cv->cv_name);
-        kfree(cv);
+  KASSERT(cv != NULL);
+
+  // add stuff here as needed
+
+  spinlock_cleanup(&cv->cv_spinlock);
+  wchan_destroy(cv->cv_wchan);
+
+  // end add stuff
+
+  kfree(cv->cv_name);
+  kfree(cv);
 }
 
 void
 cv_wait(struct cv *cv, struct lock *lock)
 {
-        // Write this
-        (void)cv;    // suppress warning until code gets written
-        (void)lock;  // suppress warning until code gets written
+
+  // Write this
+
+  int spinlock_flag = 0;
+
+  KASSERT(curthread->t_in_interrupt == false);
+
+  spinlock_acquire(&cv->cv_spinlock);
+
+  if (lock_do_i_hold(lock)) {
+
+    lock_release(lock);
+
+    wchan_lock(cv->cv_wchan);
+    spinlock_flag = 1;
+    spinlock_release(&cv->cv_spinlock);
+
+    wchan_sleep(cv->cv_wchan);
+    lock_acquire(lock);
+
+  }
+
+  // If you don't hold the lock
+  if (!spinlock_flag)
+    spinlock_release(&cv->cv_spinlock);
+
+  // end write this
+
+  // (void)cv;    // suppress warning until code gets written
+  // (void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_signal(struct cv *cv, struct lock *lock)
 {
-        // Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+
+  // Write this
+
+  int spinlock_flag = 0;
+
+  KASSERT(curthread->t_in_interrupt == false);
+
+  spinlock_acquire(&cv->cv_spinlock);
+
+  if (lock_do_i_hold(lock)) {
+
+    spinlock_acquire(&cv->cv_spinlock);
+    wchan_wakeone(cv->cv_wchan);
+    spinlock_flag = 1;
+    spinlock_release(&cv->cv_spinlock);
+  }
+
+  if (!spinlock_flag)
+    spinlock_release(&cv->cv_spinlock);
+
+  // end write this
+
+  //(void)cv;    // suppress warning until code gets written
+  //(void)lock;  // suppress warning until code gets written
 }
 
 void
 cv_broadcast(struct cv *cv, struct lock *lock)
 {
-	// Write this
-	(void)cv;    // suppress warning until code gets written
-	(void)lock;  // suppress warning until code gets written
+
+  // Write this
+
+  int spinlock_flag = 0;
+
+  KASSERT(curthread->t_in_interrupt == false);
+
+  spinlock_acquire(&cv->cv_spinlock);
+
+  if (lock_do_i_hold(lock)) {
+
+    wchan_wakeall(cv->cv_wchan);
+
+    spinlock_flag = 1;
+
+    spinlock_release(&cv->cv_spinlock);
+  }
+
+  if (!spinlock_flag)
+    spinlock_release(&cv->cv_spinlock);
+
+  // end write this
+
+  //(void)cv;    // suppress warning until code gets written
+  //(void)lock;  // suppress warning until code gets written
+}
+
+
+/////////////////////////////////////////////////////
+// RW Locks
+//
+
+/*struct rwlock * rwlock_create(const char *name) {
+
+  struct rwlock *rwlock;
+
+  rwlock = kmalloc(sizeof(struct rwlock));
+  if (rwlock == NULL) return NULL;
+
+  rwlock->rwl_name = kstrdup(name);
+  if (rwlock->rwl_name == NULL) {
+    kfree(lock);
+    return NULL;
+  }
+
+  rwlock->rwl_rwchan = wchan_create("RWLock Reader Wait Channel");
+  rwlock->rwl_wwchan = wchan_create("RWLock Writer Wait Channel");
+  if (rwlock->rwl_rwchan == NULL || rwlock->rwl_rwchan == NULL) {
+    kfree (rwlock->rwl_name);
+    kfree (rwlock);
+    return NULL;
+  }
+
+  spinlock_init(&rwlock->rwl_spinlock);
+
+  mode = -1;
+
+  sem_create(rwlock->rwl_rsem);
+  sem_create(rwlock->rwl_wsem);
+  if (rwlock->rwl_rsem == NULL || rwlock->rwl_wsem == NULL) {
+    kfree (rwlock->rwl_name);
+    kfree (rwlock);
+  }
+  return rwlock;
+}
+
+void rwlock_destory(struct rwlock *rwlock) {
+
+  KASSERT(rwlock != NULL);
+
+  spinlock_cleanup (&rwlock->rwl_spinlock);
+  wchan_destroy (rwlock->rwl_rwchan);
+  wchan_destroy (rwlock->rwl_wwchan);
+  sem_destory (rwlock->rsem);
+  sem_destory (rwlock->wsem);
+  kfree (rwlock->rwl_name);
+  kfree (rwlock);
 }
+
+void rwlock_acquire_read(struct rwlock *rwlock) {
+
+  KASSERT(rwlock != NULL)
+
+}
+
+void rwlock_read_release(struct rwlock * rwlock) {
+
+  KASSERT(rwlock != NULL);
+
+}
+
+void rwlock_acquire_write(struct rwlock *rwlock) {
+
+  (void) rwlock;
+
+  return;
+}*/
diff --git a/kern/thread/thread.c b/kern/thread/thread.c
index e7235e3..ad4adf6 100644
--- a/kern/thread/thread.c
+++ b/kern/thread/thread.c
@@ -48,6 +48,11 @@
 #include <mainbus.h>
 #include <vnode.h>
 
+// System Calls
+#include <syscall.h>
+//#include <proc.h>
+//#include <file.h>
+
 #include "opt-synchprobs.h"
 #include "opt-defaultscheduler.h"
 
@@ -118,6 +123,7 @@ struct thread *
 thread_create(const char *name)
 {
 	struct thread *thread;
+  int i;
 
 	DEBUGASSERT(name != NULL);
 
@@ -154,6 +160,15 @@ thread_create(const char *name)
 
 	/* If you add to struct thread, be sure to initialize here */
 
+  // Clear the table!
+  for (i = 0; i < OPEN_MAX; i++)
+      thread->file_desctable[i] = NULL;
+
+  // Process syscall stuff
+  // init's favourite song is Name (that and slide for me).
+  thread->ppid = 2;
+  assign_pid(thread);
+
 	return thread;
 }
 
@@ -263,7 +278,8 @@ thread_destroy(struct thread *thread)
 	thread->t_wchan_name = "DESTROYED";
 
 	kfree(thread->t_name);
-	kfree(thread);
+
+  kfree(thread);
 }
 
 /*
@@ -791,7 +807,6 @@ void
 thread_exit(void)
 {
 	struct thread *cur;
-
 	cur = curthread;
 
 	/* VFS fields */
diff --git a/kern/vm/addrspace.c b/kern/vm/addrspace.c
index 302fa7b..7ef3259 100644
--- a/kern/vm/addrspace.c
+++ b/kern/vm/addrspace.c
@@ -1,37 +1,202 @@
-/*
- * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions
- * are met:
- * 1. Redistributions of source code must retain the above copyright
- *    notice, this list of conditions and the following disclaimer.
- * 2. Redistributions in binary form must reproduce the above copyright
- *    notice, this list of conditions and the following disclaimer in the
- *    documentation and/or other materials provided with the distribution.
- * 3. Neither the name of the University nor the names of its contributors
- *    may be used to endorse or promote products derived from this software
- *    without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE UNIVERSITY AND CONTRIBUTORS ``AS IS'' AND
- * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED.  IN NO EVENT SHALL THE UNIVERSITY OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
- * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
- * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
- * SUCH DAMAGE.
- */
-
 #include <types.h>
 #include <kern/errno.h>
 #include <lib.h>
-#include <addrspace.h>
+#include <spl.h>
+#include <mips/tlb.h>
 #include <vm.h>
+#include <addrspace.h>
+#include <synch.h>
+
+
+
+struct addrspace *
+as_create(void)
+{
+  struct addrspace *as = kmalloc(sizeof(struct addrspace));
+  if (as==NULL) {
+    return NULL;
+  }
+
+  as->as_vbase1 = 0;
+  as->as_pbase1 = 0;
+  as->as_npages1 = 0;
+  as->as_vbase2 = 0;
+  as->as_pbase2 = 0;
+  as->as_npages2 = 0;
+  as->as_stackpbase = 0;
+
+  return as;
+}
+
+void
+as_destroy(struct addrspace *as)
+{
+  kfree(as);
+}
+
+void
+as_activate(struct addrspace *as)
+{
+  int i, spl;
+
+  (void)as;
+
+  /* Disable interrupts on this CPU while frobbing the TLB. */
+  spl = splhigh();
+
+  for (i=0; i<NUM_TLB; i++) {
+    tlb_write(TLBHI_INVALID(i), TLBLO_INVALID(), i);
+  }
+
+  splx(spl);
+}
+
+int
+as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
+     int readable, int writeable, int executable)
+{
+  size_t npages; 
+
+  /* Align the region. First, the base... */
+  sz += vaddr & ~(vaddr_t)PAGE_FRAME;
+  vaddr &= PAGE_FRAME;
+
+  /* ...and now the length. */
+  sz = (sz + PAGE_SIZE - 1) & PAGE_FRAME;
+
+  npages = sz / PAGE_SIZE;
+
+  /* We don't use these - all pages are read-write */
+  (void)readable;
+  (void)writeable;
+  (void)executable;
+
+  if (as->as_vbase1 == 0) {
+    as->as_vbase1 = vaddr;
+    as->as_npages1 = npages;
+    return 0;
+  }
+
+  if (as->as_vbase2 == 0) {
+    as->as_vbase2 = vaddr;
+    as->as_npages2 = npages;
+    return 0;
+  }
+
+  /*
+   * Support for more than two regions is not available.
+   */
+  kprintf("dumbvm: Warning: too many regions\n");
+  return EUNIMP;
+}
+
+void as_zero_region(paddr_t paddr, unsigned npages) {
+  bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+}
+
+int
+as_prepare_load(struct addrspace *as)
+{
+  KASSERT(as->as_pbase1 == 0);
+  KASSERT(as->as_pbase2 == 0);
+  KASSERT(as->as_stackpbase == 0);
+
+  as->as_pbase1 = getppages(as->as_npages1, DIRTY);
+  if (as->as_pbase1 == 0) {
+    return ENOMEM;
+  }
+
+  as->as_pbase2 = getppages(as->as_npages2, DIRTY);
+  if (as->as_pbase2 == 0) {
+    return ENOMEM;
+  }
+
+  as->as_stackpbase = getppages(DUMBVM_STACKPAGES, DIRTY);
+  if (as->as_stackpbase == 0) {
+    return ENOMEM;
+  }
+  
+  as_zero_region(as->as_pbase1, as->as_npages1);
+  as_zero_region(as->as_pbase2, as->as_npages2);
+  as_zero_region(as->as_stackpbase, DUMBVM_STACKPAGES);
+
+  return 0;
+}
+
+int
+as_complete_load(struct addrspace *as)
+{
+  (void)as;
+  return 0;
+}
+
+int
+as_define_stack(struct addrspace *as, vaddr_t *stackptr)
+{
+  KASSERT(as->as_stackpbase != 0);
+
+  *stackptr = USERSTACK;
+  return 0;
+}
+
+int
+as_copy(struct addrspace *old, struct addrspace **ret)
+{
+  struct addrspace *new;
+
+  new = as_create();
+  if (new==NULL) {
+    return ENOMEM;
+  }
+
+  new->as_vbase1 = old->as_vbase1;
+  new->as_npages1 = old->as_npages1;
+  new->as_vbase2 = old->as_vbase2;
+  new->as_npages2 = old->as_npages2;
+
+  /* (Mis)use as_prepare_load to allocate some physical memory. */
+  if (as_prepare_load(new)) {
+    as_destroy(new);
+    return ENOMEM;
+  }
+
+  KASSERT(new->as_pbase1 != 0);
+  KASSERT(new->as_pbase2 != 0);
+  KASSERT(new->as_stackpbase != 0);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_pbase1),
+    (const void *)PADDR_TO_KVADDR(old->as_pbase1),
+    old->as_npages1*PAGE_SIZE);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_pbase2),
+    (const void *)PADDR_TO_KVADDR(old->as_pbase2),
+    old->as_npages2*PAGE_SIZE);
+
+  memmove((void *)PADDR_TO_KVADDR(new->as_stackpbase),
+    (const void *)PADDR_TO_KVADDR(old->as_stackpbase),
+    DUMBVM_STACKPAGES*PAGE_SIZE);
+  
+  *ret = new;
+  return 0;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
 
 /*
  * Note! If OPT_DUMBVM is set, as is the case until you start the VM
@@ -39,64 +204,66 @@
  * used. The cheesy hack versions in dumbvm.c are used instead.
  */
 
-struct addrspace *
-as_create(void)
-{
-	struct addrspace *as;
+/*struct addrspace * as_create(void) {
+
+  struct addrspace *as;
+
+  // My stuff got put here.
+
+  as->as_vbase1 = 0;
+  as->as_pbase1 = 0;
+  as->as_npages1 = 0;
+  as->as_vbase2 = 0;
+  as->as_pbase2 = 0;
+  as->as_npages2 = 0;
+  as->as_stackpbase = 0;
 
-	as = kmalloc(sizeof(struct addrspace));
-	if (as == NULL) {
-		return NULL;
-	}
+  as->pagetablehead = alloc_upages(1);
 
-	/*
-	 * Initialize as needed.
-	 */
+  // My stuff ended.
 
-	return as;
+  return as;
 }
 
 int
 as_copy(struct addrspace *old, struct addrspace **ret)
 {
-	struct addrspace *newas;
 
-	newas = as_create();
-	if (newas==NULL) {
-		return ENOMEM;
-	}
+  struct addrspace *newas;
 
-	/*
-	 * Write this.
-	 */
+  newas = as_create();
+  if (newas==NULL) {
+    return ENOMEM;
+  }
 
-	(void)old;
-	
-	*ret = newas;
-	return 0;
+  // My stuff got put here
+
+  (void)old;
+
+  // My stuff ended.
+
+  *ret = newas;
+  return 0;
 }
 
 void
 as_destroy(struct addrspace *as)
 {
-	/*
-	 * Clean up as needed.
-	 */
-	
-	kfree(as);
+  // Clean up as needed.
+
+  kfree(as);
 }
 
 void
 as_activate(struct addrspace *as)
 {
-	/*
-	 * Write this.
-	 */
+  // Write this.
 
-	(void)as;  // suppress warning until code gets written
-}
+  (void)as;
 
-/*
+}*/
+
+ /*
  * Set up a segment at virtual address VADDR of size MEMSIZE. The
  * segment in memory extends from VADDR up to (but not including)
  * VADDR+MEMSIZE.
@@ -106,57 +273,55 @@ as_activate(struct addrspace *as)
  * moment, these are ignored. When you write the VM system, you may
  * want to implement them.
  */
-int
-as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz,
-		 int readable, int writeable, int executable)
-{
-	/*
-	 * Write this.
-	 */
 
-	(void)as;
-	(void)vaddr;
-	(void)sz;
-	(void)readable;
-	(void)writeable;
-	(void)executable;
-	return EUNIMP;
+/*int as_define_region(struct addrspace *as, vaddr_t vaddr, size_t sz, int readable, int writeable, int executable) {
+
+  // Write this.
+  (void)as;
+  (void)vaddr;
+  (void)sz;
+  (void)readable;
+  (void)writeable;
+  (void)executable;
+  return EUNIMP;
+
+  return 0;
 }
 
-int
-as_prepare_load(struct addrspace *as)
-{
-	/*
-	 * Write this.
-	 */
+//static void as_zero_region(paddr_t paddr, unsigned npages) {
+  bzero((void *)PADDR_TO_KVADDR(paddr), npages * PAGE_SIZE);
+}
 
-	(void)as;
-	return 0;
+int as_prepare_load(struct addrspace *as) {
+
+  // Write this.
+
+  (void)as;
+  return 0;
 }
 
-int
-as_complete_load(struct addrspace *as)
-{
-	/*
-	 * Write this.
-	 */
+int as_complete_load(struct addrspace *as) {
 
-	(void)as;
-	return 0;
+  // Write this.
+  (void)as;
+  return 0;
 }
 
-int
-as_define_stack(struct addrspace *as, vaddr_t *stackptr)
-{
-	/*
-	 * Write this.
-	 */
+int as_define_stack(struct addrspace *as, vaddr_t *stackptr) {
 
-	(void)as;
+  struct addrspace *new;
 
-	/* Initial user-level stack pointer */
-	*stackptr = USERSTACK;
-	
-	return 0;
-}
+  new = as_create();
+  if (new == NULL) {
+    return ENOMEM;
+  }
+
+  // Write this.
+
+  (void) as;
+
+  // Initial user-level stack pointer
+  *stackptr = USERSTACK;
 
+  return 0;
+}*/
diff --git a/kern/vm/copyinout.c b/kern/vm/copyinout.c
index 39843e7..075aa98 100644
--- a/kern/vm/copyinout.c
+++ b/kern/vm/copyinout.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -99,7 +99,7 @@ static
 void
 copyfail(void)
 {
-	longjmp(curthread->t_machdep.tm_copyjmp, 1);
+  longjmp(curthread->t_machdep.tm_copyjmp, 1);
 }
 
 /*
@@ -117,29 +117,29 @@ static
 int
 copycheck(const_userptr_t userptr, size_t len, size_t *stoplen)
 {
-	vaddr_t bot, top;
+  vaddr_t bot, top;
 
-	*stoplen = len;
+  *stoplen = len;
 
-	bot = (vaddr_t) userptr;
-	top = bot+len-1;
+  bot = (vaddr_t) userptr;
+  top = bot+len-1;
 
-	if (top < bot) {
-		/* addresses wrapped around */
-		return EFAULT;
-	}
+  if (top < bot) {
+    /* addresses wrapped around */
+    return EFAULT;
+  }
 
-	if (bot >= USERSPACETOP) {
-		/* region is within the kernel */
-		return EFAULT;
-	}
+  if (bot >= USERSPACETOP) {
+    /* region is within the kernel */
+    return EFAULT;
+  }
 
-	if (top >= USERSPACETOP) {
-		/* region overlaps the kernel. adjust the max length. */
-		*stoplen = USERSPACETOP - bot;
-	}
+  if (top >= USERSPACETOP) {
+    /* region overlaps the kernel. adjust the max length. */
+    *stoplen = USERSPACETOP - bot;
+  }
 
-	return 0;
+  return 0;
 }
 
 /*
@@ -152,30 +152,30 @@ copycheck(const_userptr_t userptr, size_t len, size_t *stoplen)
 int
 copyin(const_userptr_t usersrc, void *dest, size_t len)
 {
-	int result;
-	size_t stoplen;
-
-	result = copycheck(usersrc, len, &stoplen);
-	if (result) {
-		return result;
-	}
-	if (stoplen != len) {
-		/* Single block, can't legally truncate it. */
-		return EFAULT;
-	}
-
-	curthread->t_machdep.tm_badfaultfunc = copyfail;
-
-	result = setjmp(curthread->t_machdep.tm_copyjmp);
-	if (result) {
-		curthread->t_machdep.tm_badfaultfunc = NULL;
-		return EFAULT;
-	}
-
-	memcpy(dest, (const void *)usersrc, len);
-
-	curthread->t_machdep.tm_badfaultfunc = NULL;
-	return 0;
+  int result;
+  size_t stoplen;
+
+  result = copycheck(usersrc, len, &stoplen);
+  if (result) {
+    return result;
+  }
+  if (stoplen != len) {
+    /* Single block, can't legally truncate it. */
+    return EFAULT;
+  }
+
+  curthread->t_machdep.tm_badfaultfunc = copyfail;
+
+  result = setjmp(curthread->t_machdep.tm_copyjmp);
+  if (result) {
+    curthread->t_machdep.tm_badfaultfunc = NULL;
+    return EFAULT;
+  }
+
+  memcpy(dest, (const void *)usersrc, len);
+
+  curthread->t_machdep.tm_badfaultfunc = NULL;
+  return 0;
 }
 
 /*
@@ -188,30 +188,30 @@ copyin(const_userptr_t usersrc, void *dest, size_t len)
 int
 copyout(const void *src, userptr_t userdest, size_t len)
 {
-	int result;
-	size_t stoplen;
-
-	result = copycheck(userdest, len, &stoplen);
-	if (result) {
-		return result;
-	}
-	if (stoplen != len) {
-		/* Single block, can't legally truncate it. */
-		return EFAULT;
-	}
-
-	curthread->t_machdep.tm_badfaultfunc = copyfail;
-
-	result = setjmp(curthread->t_machdep.tm_copyjmp);
-	if (result) {
-		curthread->t_machdep.tm_badfaultfunc = NULL;
-		return EFAULT;
-	}
-
-	memcpy((void *)userdest, src, len);
-
-	curthread->t_machdep.tm_badfaultfunc = NULL;
-	return 0;
+  int result;
+  size_t stoplen;
+
+  result = copycheck(userdest, len, &stoplen);
+  if (result) {
+    return result;
+  }
+  if (stoplen != len) {
+    /* Single block, can't legally truncate it. */
+    return EFAULT;
+  }
+
+  curthread->t_machdep.tm_badfaultfunc = copyfail;
+
+  result = setjmp(curthread->t_machdep.tm_copyjmp);
+  if (result) {
+    curthread->t_machdep.tm_badfaultfunc = NULL;
+    return EFAULT;
+  }
+
+  memcpy((void *)userdest, src, len);
+
+  curthread->t_machdep.tm_badfaultfunc = NULL;
+  return 0;
 }
 
 /*
@@ -233,25 +233,25 @@ copyout(const void *src, userptr_t userdest, size_t len)
 static
 int
 copystr(char *dest, const char *src, size_t maxlen, size_t stoplen,
-	size_t *gotlen)
+  size_t *gotlen)
 {
-	size_t i;
-
-	for (i=0; i<maxlen && i<stoplen; i++) {
-		dest[i] = src[i];
-		if (src[i] == 0) {
-			if (gotlen != NULL) {
-				*gotlen = i+1;
-			}
-			return 0;
-		}
-	}
-	if (stoplen < maxlen) {
-		/* ran into user-kernel boundary */
-		return EFAULT;
-	}
-	/* otherwise just ran out of space */
-	return ENAMETOOLONG;
+  size_t i;
+
+  for (i=0; i<maxlen && i<stoplen; i++) {
+    dest[i] = src[i];
+    if (src[i] == 0) {
+      if (gotlen != NULL) {
+        *gotlen = i+1;
+      }
+      return 0;
+    }
+  }
+  if (stoplen < maxlen) {
+    /* ran into user-kernel boundary */
+    return EFAULT;
+  }
+  /* otherwise just ran out of space */
+  return ENAMETOOLONG;
 }
 
 /*
@@ -265,26 +265,26 @@ copystr(char *dest, const char *src, size_t maxlen, size_t stoplen,
 int
 copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *actual)
 {
-	int result;
-	size_t stoplen;
+  int result;
+  size_t stoplen;
 
-	result = copycheck(usersrc, len, &stoplen);
-	if (result) {
-		return result;
-	}
+  result = copycheck(usersrc, len, &stoplen);
+  if (result) {
+    return result;
+  }
 
-	curthread->t_machdep.tm_badfaultfunc = copyfail;
+  curthread->t_machdep.tm_badfaultfunc = copyfail;
 
-	result = setjmp(curthread->t_machdep.tm_copyjmp);
-	if (result) {
-		curthread->t_machdep.tm_badfaultfunc = NULL;
-		return EFAULT;
-	}
+  result = setjmp(curthread->t_machdep.tm_copyjmp);
+  if (result) {
+    curthread->t_machdep.tm_badfaultfunc = NULL;
+    return EFAULT;
+  }
 
-	result = copystr(dest, (const char *)usersrc, len, stoplen, actual);
+  result = copystr(dest, (const char *)usersrc, len, stoplen, actual);
 
-	curthread->t_machdep.tm_badfaultfunc = NULL;
-	return result;
+  curthread->t_machdep.tm_badfaultfunc = NULL;
+  return result;
 }
 
 /*
@@ -298,24 +298,24 @@ copyinstr(const_userptr_t usersrc, char *dest, size_t len, size_t *actual)
 int
 copyoutstr(const char *src, userptr_t userdest, size_t len, size_t *actual)
 {
-	int result;
-	size_t stoplen;
+  int result;
+  size_t stoplen;
 
-	result = copycheck(userdest, len, &stoplen);
-	if (result) {
-		return result;
-	}
+  result = copycheck(userdest, len, &stoplen);
+  if (result) {
+    return result;
+  }
 
-	curthread->t_machdep.tm_badfaultfunc = copyfail;
+  curthread->t_machdep.tm_badfaultfunc = copyfail;
 
-	result = setjmp(curthread->t_machdep.tm_copyjmp);
-	if (result) {
-		curthread->t_machdep.tm_badfaultfunc = NULL;
-		return EFAULT;
-	}
+  result = setjmp(curthread->t_machdep.tm_copyjmp);
+  if (result) {
+    curthread->t_machdep.tm_badfaultfunc = NULL;
+    return EFAULT;
+  }
 
-	result = copystr((char *)userdest, src, len, stoplen, actual);
+  result = copystr((char *)userdest, src, len, stoplen, actual);
 
-	curthread->t_machdep.tm_badfaultfunc = NULL;
-	return result;
+  curthread->t_machdep.tm_badfaultfunc = NULL;
+  return result;
 }
diff --git a/user/include/sys/types.h b/user/include/sys/types.h
index a3f8f94..5793461 100644
--- a/user/include/sys/types.h
+++ b/user/include/sys/types.h
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
diff --git a/user/include/unistd.h b/user/include/unistd.h
index a9b2ca3..5299982 100644
--- a/user/include/unistd.h
+++ b/user/include/unistd.h
@@ -44,7 +44,8 @@
 #include <kern/time.h>
 #include <kern/unistd.h>
 #include <kern/wait.h>
-
+//#include <kern/file.h>
+//#include <kern/proc.h>
 
 /*
  * Prototypes for OS/161 system calls.
diff --git a/user/testbin/argtest/argtest.c b/user/testbin/argtest/argtest.c
index 7ed552e..ff9a318 100644
--- a/user/testbin/argtest/argtest.c
+++ b/user/testbin/argtest/argtest.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -40,18 +40,21 @@
 int
 main(int argc, char *argv[])
 {
-	const char *tmp;
-	int i;
+  const char *temp;
+  char *ptr;
+  int i;
 
-	printf("argc: %d\n", argc);
+  printf("argc: %d\n", argc);
 
-	for (i=0; i<=argc; i++) {
-		tmp = argv[i];
-		if (tmp==NULL) {
-			tmp = "[NULL]";
-		}
-		printf("argv[%d]: %s\n", i, tmp);
-	}
+  for (i=0; i<=argc; i++) {
+    temp = argv[i];
+    if (temp==NULL) {
+      temp = "[NULL]";
+    }
+    ptr = (char *)(argv + i);
+    //printf("argv[%d]: %s\n", i, temp);
+    printf("argv[%d]: %p - %s\n", i, ptr, temp);
+  }
 
-	return 0;
+  return 0;
 }
diff --git a/user/testbin/fileonlytest/fileonlytest.c b/user/testbin/fileonlytest/fileonlytest.c
index b807ff6..21678fe 100644
--- a/user/testbin/fileonlytest/fileonlytest.c
+++ b/user/testbin/fileonlytest/fileonlytest.c
@@ -137,7 +137,7 @@ main(int argc, char **argv)
     }
 		len = read(fh, readbuf, sizeof(readbuf));
 		if (len != sizeof(readbuf)) {
-			err(1, "read failed");
+			err(1, "read failed, len:%d", len);
 		}
 		for (j = BUFFER_SIZE - 1; j >= 0; j--) {
 			if (readbuf[j] != i * j) {
diff --git a/user/testbin/fileonlytestuser/Makefile b/user/testbin/fileonlytestuser/Makefile
new file mode 100644
index 0000000..eb39613
--- /dev/null
+++ b/user/testbin/fileonlytestuser/Makefile
@@ -0,0 +1,11 @@
+# Makefile for fileonlytest
+
+TOP=../../..
+.include "$(TOP)/mk/os161.config.mk"
+
+PROG=fileonlytestuser
+SRCS=fileonlytestuser.c
+BINDIR=/testbin
+
+.include "$(TOP)/mk/os161.prog.mk"
+
diff --git a/user/testbin/fileonlytestuser/fileonlytestuser.c b/user/testbin/fileonlytestuser/fileonlytestuser.c
new file mode 100644
index 0000000..a847dc8
--- /dev/null
+++ b/user/testbin/fileonlytestuser/fileonlytestuser.c
@@ -0,0 +1,61 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <err.h>
+
+int
+main(int argc, char **argv)
+{
+
+  (void) argc;
+  (void) argv;
+  int fh, len;
+  off_t pos, target;
+
+  char writebuf[13], readbuf[13];
+
+  strcpy(writebuf, "abcdefghijkl");
+
+  const char * filename = "fileonlytest.dat";
+
+  printf("Opening %s\n", filename);
+
+  fh = open(filename, O_RDWR|O_CREAT|O_TRUNC);
+  if (fh < 0) {
+    err(1, "create failed");
+  }
+
+  len = write(fh, writebuf, sizeof(writebuf));
+  if (len != sizeof(writebuf)) {
+    err(1, "write failed");
+  }
+
+  target = 0;
+  pos = lseek(fh, target, SEEK_SET);
+  if (pos != target) {
+    err(1, "lseek failed: %llu != %llu", pos, target);
+  }
+
+  printf("Verifying write.\n");
+
+  len = read(fh, readbuf, sizeof(readbuf));
+  if (len != sizeof(readbuf)) {
+    err(1, "read failed, len:%d", len);
+  }
+
+  printf("Closing %s\n", filename);
+  close(fh);
+
+  /*pos = lseek(fh, (off_t) 0, SEEK_SET);
+  if (pos == 0) {
+    err(1, "seek after close succeeded");
+  }
+
+  // 23 Mar 2012 : GWA : FIXME : Spin until exit() works.*/
+
+  printf("Spinning in case exit() doesn't work.\n");
+  while (1) {};
+
+  return 0;
+}
diff --git a/user/testbin/filetest/filetest.c b/user/testbin/filetest/filetest.c
index 754598b..25d1419 100644
--- a/user/testbin/filetest/filetest.c
+++ b/user/testbin/filetest/filetest.c
@@ -47,7 +47,7 @@ int
 main(int argc, char *argv[])
 {
 	static char writebuf[40] = "Twiddle dee dee, Twiddle dum dum.......\n";
-	static char readbuf[41];
+	//static char readbuf[41];
 
 	int fd, rv;
 
@@ -71,7 +71,7 @@ main(int argc, char *argv[])
 		err(1, "%s: close (1st time)", argv[1]);
 	}
 
-	fd = open(argv[1], O_RDONLY);
+	/*fd = open(argv[1], O_RDONLY);
 	if (fd<0) { 
 		err(1, "%s: open for read", argv[1]);
 	}
@@ -84,7 +84,7 @@ main(int argc, char *argv[])
 	if (rv<0) {
 		err(1, "%s: close (2nd time)", argv[1]);
 	}
-	/* ensure null termination */
+	* ensure null termination 
 	readbuf[40] = 0;
 
 	if (strcmp(readbuf, writebuf)) {
@@ -94,7 +94,7 @@ main(int argc, char *argv[])
 	rv = remove(argv[1]);
 	if (rv<0) {
 		err(1, "%s: remove", argv[1]);
-	}
+	}*/
 	printf("Passed filetest.\n");
 	return 0;
 }
diff --git a/user/testbin/forktest/forktest.c b/user/testbin/forktest/forktest.c
index 50d72b0..aef1169 100644
--- a/user/testbin/forktest/forktest.c
+++ b/user/testbin/forktest/forktest.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -55,12 +55,12 @@ static
 int
 dofork(void)
 {
-	int pid;
-	pid = fork();
-	if (pid < 0) {
-		warn("fork");
-	}
-	return pid;
+  int pid;
+  pid = fork();
+  if (pid < 0) {
+    warn("fork");
+  }
+  return pid;
 }
 
 /*
@@ -72,26 +72,26 @@ static
 void
 check(void)
 {
-	int i;
-
-	mypid = getpid();
-	
-	/* Make sure each fork has its own address space. */
-	for (i=0; i<800; i++) {
-		volatile int seenpid;
-		seenpid = mypid;
-		if (seenpid != getpid()) {
-			errx(1, "pid mismatch (%d, should be %d) "
-			     "- your vm is broken!", 
-			     seenpid, getpid());
-		}
-	}
+  int i;
+
+  mypid = getpid();
+
+  //Make sure each fork has its own address space. 
+  for (i=0; i<800; i++) {
+    volatile int seenpid;
+    seenpid = mypid;
+    if (seenpid != getpid()) {
+      errx(1, "pid mismatch (%d, should be %d) "
+           "- your vm is broken!", 
+           seenpid, getpid());
+    }
+  }
 }
 
 /*
  * Wait for a child process.
  *
- * This assumes dowait is called the same number of times as dofork
+ * This assumes dowait is called the same number of times as docfork
  * and passed its results in reverse order. Any forks that fail send
  * us -1 and are ignored. The first 0 we see indicates the fork that
  * generated the current process; that means it's time to exit. Only
@@ -101,28 +101,28 @@ static
 void
 dowait(int nowait, int pid)
 {
-	int x;
-
-	if (pid<0) {
-		/* fork in question failed; just return */
-		return;
-	}
-	if (pid==0) {
-		/* in the fork in question we were the child; exit */
-		exit(0);
-	}
-
-	if (!nowait) {
-		if (waitpid(pid, &x, 0)<0) {
-			warn("waitpid");
-		}
-		else if (WIFSIGNALED(x)) {
-			warnx("pid %d: signal %d", pid, WTERMSIG(x));
-		}
-		else if (WEXITSTATUS(x) != 0) {
-			warnx("pid %d: exit %d", pid, WEXITSTATUS(x));
-		}
-	}
+  int x;
+
+  if (pid<0) {
+    //fork in question failed; just return 
+    return;
+  }
+  if (pid==0) {
+     //in the fork in question we were the child; exit 
+    exit(0);
+  }
+
+  if (!nowait) {
+    if (waitpid(pid, &x, 0)<0) {
+      warn("waitpid");
+    }
+    else if (WIFSIGNALED(x)) {
+      warnx("pid %d: signal %d", pid, WTERMSIG(x));
+    }
+    else if (WEXITSTATUS(x) != 0) {
+      warnx("pid %d: exit %d", pid, WEXITSTATUS(x));
+    }
+  }
 }
 
 /*
@@ -132,56 +132,56 @@ static
 void
 test(int nowait)
 {
-	int pid0, pid1, pid2, pid3;
-
-	/*
-	 * Caution: This generates processes geometrically.
-	 *
-	 * It is unrolled to encourage gcc to registerize the pids,
-	 * to prevent wait/exit problems if fork corrupts memory.
-	 */
-
-	pid0 = dofork();
-	putchar('0');
-	check();
-	pid1 = dofork();
-	putchar('1');
-	check();
-	pid2 = dofork();
-	putchar('2');
-	check();
-	pid3 = dofork();
-	putchar('3');
-	check();
-
-	/*
-	 * These must be called in reverse order to avoid waiting
-	 * improperly.
-	 */
-	dowait(nowait, pid3);
-	dowait(nowait, pid2);
-	dowait(nowait, pid1);
-	dowait(nowait, pid0);
-
-	putchar('\n');
+  int pid0, pid1, pid2, pid3;
+
+  /*
+   * Caution: This generates processes geometrically.
+   *
+   * It is unrolled to encourage gcc to registerize the pids,
+   * to prevent wait/exit problems if fork corrupts memory.
+   */
+
+  pid0 = dofork();
+  putchar('0');
+  check();
+  pid1 = dofork();
+  putchar('1');
+  check();
+  pid2 = dofork();
+  putchar('2');
+  check();
+  pid3 = dofork();
+  putchar('3');
+  check();
+
+  /*
+   * These must be called in reverse order to avoid waiting
+   * improperly.
+   */
+  dowait(nowait, pid3);
+  dowait(nowait, pid2);
+  dowait(nowait, pid1);
+  dowait(nowait, pid0);
+
+  putchar('\n');
 }
 
 int
 main(int argc, char *argv[])
 {
-	int nowait=0;
+  int nowait=0;
 
-	if (argc==2 && !strcmp(argv[1], "-w")) {
-		nowait=1;
-	}
-	else if (argc!=1 && argc!=0) {
-		warnx("usage: forktest [-w]");
-		return 1;
-	}
-	warnx("Starting.");
+  if (argc==2 && !strcmp(argv[1], "-w")) {
+    nowait=1;
+  }
+  else if (argc!=1 && argc!=0) {
+    warnx("usage: forktest [-w]");
+    return 1;
+  }
+  warnx("Starting.");
 
-	test(nowait);
+  test(nowait);
 
-	warnx("Complete.");
-	return 0;
+  warnx("Complete.");
+  return 0;
 }
diff --git a/user/testbin/hash/hash.c b/user/testbin/hash/hash.c
index 68f523a..c3c7aea 100644
--- a/user/testbin/hash/hash.c
+++ b/user/testbin/hash/hash.c
@@ -1,6 +1,6 @@
 /*
  * Copyright (c) 2000, 2001, 2002, 2003, 2004, 2005, 2008, 2009
- *	The President and Fellows of Harvard College.
+ *  The President and Fellows of Harvard College.
  *
  * Redistribution and use in source and binary forms, with or without
  * modification, are permitted provided that the following conditions
@@ -52,32 +52,32 @@
 int
 main(int argc, char *argv[])
 {
-	int fd;
-	char readbuf[1];
-	int j = 0;
+  int fd;
+  char readbuf[1];
+  int j = 0;
 
 #ifdef HOST
-	hostcompat_init(argc, argv);
+  hostcompat_init(argc, argv);
 #endif
 
-	if (argc != 2) {
-		errx(1, "Usage: hash filename");
-	}
-	
-	fd = open(argv[1], O_RDONLY, 0664);
-	
-	if (fd<0) { 
-		err(1, "%s", argv[1]);
-	}
+  if (argc != 2) {
+    errx(1, "Usage: hash filename");
+  }
 
-	for (;;) {
-		if (read(fd, readbuf, 1) <= 0) break;
-		j = ((j*8) + (int) readbuf[0]) % HASHP;
-	}
+  fd = open(argv[1], O_RDONLY, 0664);
 
-	close(fd);
-	
-	printf("Hash : %d\n", j);
+  if (fd<0) {
+    err(1, "%s", argv[1]);
+  }
 
-	return 0;
+  for (;;) {
+    if (read(fd, readbuf, 1) <= 0) break;
+    j = ((j*8) + (int) readbuf[0]) % HASHP;
+  }
+
+  close(fd);
+
+  printf("Hash : %d\n", j);
+
+  return 0;
 }
